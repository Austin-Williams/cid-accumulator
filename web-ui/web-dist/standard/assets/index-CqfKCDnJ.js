(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))o(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const s of i.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&o(s)}).observe(document,{childList:!0,subtree:!0});function n(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function o(r){if(r.ep)return;r.ep=!0;const i=n(r);fetch(r.href,i)}})();const x={ETHEREUM_HTTP_RPC_URL:"https://ethereum-rpc.publicnode.com",ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL:void 0,ETHEREUM_WS_RPC_URL:void 0,IPFS_GATEWAY_URL:"https://dweb.link",IPFS_API_URL:void 0,IPFS_PUT_IF_POSSIBLE:!0,IPFS_PIN_IF_POSSIBLE:!0,IPFS_PROVIDE_IF_POSSIBLE:!0,DB_PATH:void 0,GET_LATEST_CID_CALLDATA_OVERRIDE:void 0,GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE:void 0,LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE:void 0};var gt;const z="abcdefghijklmnopqrstuvwxyz234567";function Yt(e){let t=0,n=0,o="";for(let r=0;r<e.length;r++)for(n=n<<8|e[r],t+=8;t>=5;)o+=z[n>>>t-5&31],t-=5;return t>0&&(o+=z[n<<5-t&31]),o}function qt(e){let t=0,n=0,o=[];e=e.toLowerCase().replace(/=+$/,"");for(let r=0;r<e.length;r++)n=n<<5|z.indexOf(e[r]),t+=5,t>=8&&(o.push(n>>>t-8&255),t-=8);return new Uint8Array(o)}class h{get asCID(){return this}get byteLength(){return this.bytes.length}get byteOffset(){return 0}constructor(t,n,o,r){this[gt]="CID",this.version=t,this.code=n,this.multihash=o,this.bytes=r||h.encodeBytes(t,n,o.bytes)}equals(t){return t&&this.toString()===t.toString()}link(){return this}toJSON(){return{"/":this.toString()}}toString(t){return t&&typeof t.encode=="function"?t.encode(this.bytes):"b"+Yt(this.bytes)}toV0(){throw new Error("toV0 not supported in this minimal CID")}toV1(){if(this.version===1)return this;throw new Error("Only v1 supported in this minimal CID")}static asCID(t){return t&&t instanceof h?t:null}static create(t,n,o){return new h(t,n,o)}static createV0(t){throw new Error("CIDv0 not supported in this minimal CID")}static createV1(t,n){return new h(1,t,n)}static decode(t){if(t[0]===1){const o=h.readVarint(t,1),i=1+h.varintLength(t,1),s=h.decodeMultihash(t.slice(i));return new h(1,o.value,s,t)}throw new Error("Only CIDv1 supported")}static decodeFirst(t){const n=h.decode(t);return[n,n.bytes.length]}static equals(t,n){return t&&n&&t.toString()===n.toString()}static inspectBytes(t){return{version:t[0],codec:t[1],multihashCode:t[2]}}static parse(t){if(t[0]!=="b")throw new Error('CID string must be base32 (start with "b")');const n=qt(t.slice(1));return h.decode(n)}static encodeBytes(t,n,o){return new Uint8Array([t,n,...o])}static readVarint(t,n){return{value:t[n],length:1}}static varintLength(t,n){return 1}static decodeMultihash(t){const n=t[0],o=t[1],r=t.slice(2,2+o),i=t.slice(0,2+o);return{code:n,digest:r,size:o,bytes:i}}}gt=Symbol.toStringTag;const pt=0,yt=1,It=2,mt=3,Et=4,St=5,Ct=6,zt=7;function P(e,t){if(e<24)return new Uint8Array([t<<5|e]);if(e<256)return new Uint8Array([t<<5|24,e]);if(e<65536)return new Uint8Array([t<<5|25,e>>8,e&255]);if(e<4294967296)return new Uint8Array([t<<5|26,e>>>24&255,e>>>16&255,e>>>8&255,e&255]);throw new Error("Bigint not supported")}function _(...e){let t=e.reduce((r,i)=>r+i.length,0),n=new Uint8Array(t),o=0;for(const r of e)n.set(r,o),o+=r.length;return n}function R(e){if(e===null)return new Uint8Array([246]);if(e===!1)return new Uint8Array([244]);if(e===!0)return new Uint8Array([245]);if(typeof e=="number"){if(Number.isInteger(e))return e>=0?P(e,pt):P(-(e+1),yt);{const t=new ArrayBuffer(9),n=new DataView(t);return n.setUint8(0,251),n.setFloat64(1,e),new Uint8Array(t)}}if(typeof e=="string"){const t=new TextEncoder().encode(e);return _(P(t.length,mt),t)}if(e instanceof Uint8Array)return _(P(e.length,It),e);if(Array.isArray(e)){const t=e.map(R);return _(P(e.length,Et),...t)}if(e instanceof h){const t=P(42,Ct);let n;if(e.bytes instanceof Uint8Array)n=e.bytes;else{const r=h.asCID(e);if(!r)throw new Error("Invalid CID object passed to dagCbor encode");n=r.bytes}const o=_(new Uint8Array([0]),n);return _(t,R(o))}if(typeof e=="object"){const t=Object.keys(e),n=t.map(o=>_(R(o),R(e[o])));return _(P(t.length,St),...n)}throw new Error("Unsupported type for dag-cbor encode")}function Xt(e){let t=0;function n(){if(t>=e.length)throw new Error("Unexpected end of data");const r=e[t++],i=r>>5,s=r&31;let a=s;if(s>=24)if(s===24)a=e[t++];else if(s===25)a=e[t++]<<8|e[t++];else if(s===26)a=e[t++]<<24|e[t++]<<16|e[t++]<<8|e[t++];else throw new Error("Unsupported int size");switch(i){case pt:return a;case yt:return-1-a;case It:{const l=e.slice(t,t+a);return t+=a,l}case mt:{const l=new TextDecoder().decode(e.slice(t,t+a));return t+=a,l}case Et:{const l=[];for(let c=0;c<a;c++)l.push(n());return l}case St:{const l={};for(let c=0;c<a;c++){const u=n();l[u]=n()}return l}case Ct:if(a===42){const l=n();if(!(l instanceof Uint8Array)||l[0]!==0)throw new Error("Invalid CID tag");return h.decode(l.slice(1))}else throw new Error("Unsupported CBOR tag: "+a);case zt:if(s===20)return!1;if(s===21)return!0;if(s===22)return null;if(s===23)return;if(s===27){const l=new DataView(e.buffer,e.byteOffset+t,8).getFloat64(0);return t+=8,l}throw new Error("Unsupported CBOR simple value: "+s)}}const o=n();if(t!==e.length)throw new Error("Extra bytes after CBOR decode");return o}const Z=113,Kt="modulepreload",Qt=function(e){return"/"+e},at={},tt=function(t,n,o){let r=Promise.resolve();if(n&&n.length>0){let s=function(c){return Promise.all(c.map(u=>Promise.resolve(u).then(d=>({status:"fulfilled",value:d}),d=>({status:"rejected",reason:d}))))};document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),l=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));r=s(n.map(c=>{if(c=Qt(c),c in at)return;at[c]=!0;const u=c.endsWith(".css"),d=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${d}`))return;const f=document.createElement("link");if(f.rel=u?"stylesheet":Kt,u||(f.as="script"),f.crossOrigin="",f.href=c,l&&f.setAttribute("nonce",l),document.head.appendChild(f),u)return new Promise((w,y)=>{f.addEventListener("load",w),f.addEventListener("error",()=>y(new Error(`Unable to preload CSS for ${c}`)))})}))}function i(s){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=s,window.dispatchEvent(a),!a.defaultPrevented)throw s}return r.then(s=>{for(const a of s||[])a.status==="rejected"&&i(a.reason);return t().catch(i)})};async function et(e){var t,n;if(typeof window<"u"&&((t=window.crypto)!=null&&t.subtle)){const o=await window.crypto.subtle.digest("SHA-256",e);return new Uint8Array(o)}if(typeof process<"u"&&((n=process.versions)!=null&&n.node)){const{createHash:o}=await tt(async()=>{const{createHash:i}=await import("./__vite-browser-external-BIHI7g3E.js");return{createHash:i}},[]),r=o("sha256");return r.update(Buffer.from(e)),new Uint8Array(r.digest())}throw new Error("No suitable crypto implementation found")}function W(e,t){const n=new Uint8Array([e,t.length,...t]);return{code:e,digest:t,size:32,bytes:n}}async function F(e){const t=R(e),n=await et(t),o=W(18,n);return{cid:h.createV1(Z,o),dagCborEncodedData:t}}function Zt(e){return JSON.stringify({cid:e.cid.toString(),dagCborEncodedData:V(e.dagCborEncodedData)})}async function bt(e){const{cid:t,dagCborEncodedData:n}=JSON.parse(e);return{cid:h.parse(t),dagCborEncodedData:L(n)}}function Pt(e){const t=W(18,e);return h.create(1,113,t)}function V(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}function L(e){const t=e.startsWith("0x")?e.slice(2):e;if(t.length%2!==0)throw new Error("Hex string must have even length");const n=new Uint8Array(t.length/2);for(let o=0;o<t.length;o+=2)n[o/2]=parseInt(t.slice(o,o+2),16);return n}function te(e){return JSON.stringify({leafIndex:e.leafIndex,previousInsertBlockNumber:e.previousInsertBlockNumber,newData:V(e.newData),leftInputs:e.leftInputs.map(t=>t.toString()),blockNumber:e.blockNumber,transactionHash:e.transactionHash,removed:e.removed})}function ee(e){return JSON.stringify(e.map(t=>({cid:t.cid.toString(),height:t.height})))}async function ne(e){const t=JSON.parse(e);return Promise.all(t.map(async n=>({cid:h.parse(n.cid),height:n.height})))}function oe(e){const t=JSON.parse(e);return{leafIndex:t.leafIndex,previousInsertBlockNumber:t.previousInsertBlockNumber,newData:L(t.newData),leftInputs:t.leftInputs.map(n=>h.parse(n)),blockNumber:t.blockNumber,transactionHash:t.transactionHash,removed:t.removed}}function re(e){return{newData:e.newData,event:e,blockNumber:e.blockNumber}}async function ie(e,t){const n=await et(e),o=W(18,n);return h.createV1(Z,o).toString()===t.toString()}async function G(e,t,n){const o=await et(e),r=W(18,o),i=h.createV1(Z,r),s=n??`[Client] 💥 CID/Data pair is invalid. dagCborEncodedData: ${e}, expectedCID: ${t.toString()}, computed(actual)CID: ${i.toString()}`;if(i.toString()!==t.toString())throw new Error(s)}async function j(e,t,n){await e.put(`leaf:${t}:newData`,V(n.newData)),n.event!==void 0&&await e.put(`leaf:${t}:event`,te(n.event)),n.blockNumber!==void 0&&await e.put(`leaf:${t}:blockNumber`,n.blockNumber.toString()),n.rootCid!==void 0&&await e.put(`leaf:${t}:rootCid`,n.rootCid.toString()),n.peaksWithHeights!==void 0&&await e.put(`leaf:${t}:peaksWithHeights`,ee(n.peaksWithHeights))}async function J(e,t){const n=await e.get(`leaf:${t}:newData`);if(n==null)return;const o=L(n),r=await e.get(`leaf:${t}:event`),i=r!==void 0?oe(r):void 0,s=await e.get(`leaf:${t}:blockNumber`),a=s!==void 0?parseInt(s,10):void 0,l=await e.get(`leaf:${t}:rootCid`),c=l!==void 0?h.parse(l):void 0,u=await e.get(`leaf:${t}:peaksWithHeights`),d=u!==void 0?await ne(u):void 0;return{newData:o,event:i,blockNumber:a,rootCid:c,peaksWithHeights:d}}async function X(e,t){const n=[];for(let o=0;o<=t;o++){const r=await J(e,o);(!r||!(r.newData instanceof Uint8Array))&&n.push(o)}return n}async function se(e,t){let n=Number(await e.get("dag:trail:maxIndex")??-1);for(const o of t){try{await G(o.dagCborEncodedData,o.cid)}catch(a){console.warn("[appendTrailToDB] 💥 CID verification failed:",a,o);continue}const i=`cid:${o.cid.toString()}`;await e.get(i)||(n++,await e.put(`dag:trail:index:${n}`,Zt(o)),await e.put(i,"1"))}await e.put("dag:trail:maxIndex",n.toString())}async function _t(e,t){const n=await e.get(`dag:trail:index:${t}`);if(n&&typeof n=="string"){const o=await bt(n);return await G(o.dagCborEncodedData,o.cid),o}return null}async function*ae(e){for await(const{value:t}of e.iterate("dag:trail:index:"))t&&typeof t=="string"&&(yield bt(t))}async function Lt(e,t,n,o){const r=await t.addLeafWithTrail(n,o);await se(e,r)}async function ce(e,t){console.log("[Client] ⛰️ Rebuilding the Merkle Mountain Range from synced leaves. (Runs in background).");const n=e.leafCount,o=await t.getHighestContiguousLeafIndexWithData();if(n>o)throw new Error(`[Client] Expected to commit leaves from ${n} to ${o}, but found no newData for leaf ${n}`);if(n!==o){for(let r=n;r<=o;r++){const i=await J(t,r);if(!i||!i.newData)throw new Error(`[Client] Expected newData for leaf ${r}`);if(!(i.newData instanceof Uint8Array))throw new Error(`[Client] newData for leaf ${r} is not a Uint8Array`);await Lt(t,e,r,i.newData)}console.log(`[Client] 🎉 Fully rebuilt the Merkle Mountain Range up to leaf index ${o}`),await t.persist()}}const B=h.parse("bafyreifqwkmiw256ojf2zws6tzjeonw6bpd5vza4i22ccpcq4hjv2ts7cm");class le{constructor(){this.peaks=[],this.leafCount=0,this.leafInsertTrailSubscribers=[]}subscribeToLeafInsertTrail(t){return this.leafInsertTrailSubscribers.push(t),()=>{const n=this.leafInsertTrailSubscribers.indexOf(t);n!==-1&&this.leafInsertTrailSubscribers.splice(n,1)}}async addLeafWithTrail(t,n){if(this.leafCount!==t)throw new Error(`Expected leafIndex ${this.leafCount} but got ${t}`);const o=[],{cid:r,dagCborEncodedData:i}=await F(n);o.push({cid:r,dagCborEncodedData:i});let s=r,a=0;for(;this.leafCount>>a&1;){const c=this.peaks.pop();if(!c)throw new Error("MMR structure error: no peak to merge");const{cid:u,dagCborEncodedData:d}=await F({L:c,R:s});o.push({cid:u,dagCborEncodedData:d}),s=u,a++}this.peaks.push(s),this.leafCount++;const l=await this.rootCIDWithTrail();o.push(...l.trail);for(const c of this.leafInsertTrailSubscribers)try{c(o)}catch(u){console.error("[MMR] Error in leafInsertTrail subscriber:",u)}return o}async rootCIDWithTrail(){const t=[];if(this.peaks.length===0)return{root:B,trail:[]};if(this.peaks.length===1)return{root:this.peaks[0],trail:[]};let n=this.peaks[0];for(let o=1;o<this.peaks.length;o++){const{cid:r,dagCborEncodedData:i}=await F({L:n,R:this.peaks[o]});t.push({cid:r,dagCborEncodedData:i}),n=r}return{root:n,trail:t}}async rootCID(){return(await this.rootCIDWithTrail()).root}async rootCIDAsBase32(){return(await this.rootCID()).toString()}}function ct(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function ue(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function nt(e,...t){if(!ue(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function lt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function de(e,t){nt(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const O=BigInt(2**32-1),ut=BigInt(32);function fe(e,t=!1){return t?{h:Number(e&O),l:Number(e>>ut&O)}:{h:Number(e>>ut&O)|0,l:Number(e&O)|0}}function he(e,t=!1){let n=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:i,l:s}=fe(e[r],t);[n[r],o[r]]=[i,s]}return[n,o]}const we=(e,t,n)=>e<<n|t>>>32-n,ge=(e,t,n)=>t<<n|e>>>32-n,pe=(e,t,n)=>t<<n-32|e>>>64-n,ye=(e,t,n)=>e<<n-32|t>>>64-n;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ie(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}const dt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function me(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function ft(e){for(let t=0;t<e.length;t++)e[t]=me(e[t])}typeof Uint8Array.from([]).toHex=="function"&&Uint8Array.fromHex;function Ee(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function kt(e){return typeof e=="string"&&(e=Ee(e)),nt(e),e}class Se{clone(){return this._cloneInto()}}function Ce(e){const t=o=>e().update(kt(o)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}const Tt=[],At=[],Dt=[],be=BigInt(0),v=BigInt(1),Pe=BigInt(2),_e=BigInt(7),Le=BigInt(256),ke=BigInt(113);for(let e=0,t=v,n=1,o=0;e<24;e++){[n,o]=[o,(2*n+3*o)%5],Tt.push(2*(5*o+n)),At.push((e+1)*(e+2)/2%64);let r=be;for(let i=0;i<7;i++)t=(t<<v^(t>>_e)*ke)%Le,t&Pe&&(r^=v<<(v<<BigInt(i))-v);Dt.push(r)}const[Te,Ae]=he(Dt,!0),ht=(e,t,n)=>n>32?pe(e,t,n):we(e,t,n),wt=(e,t,n)=>n>32?ye(e,t,n):ge(e,t,n);function De(e,t=24){const n=new Uint32Array(10);for(let o=24-t;o<24;o++){for(let s=0;s<10;s++)n[s]=e[s]^e[s+10]^e[s+20]^e[s+30]^e[s+40];for(let s=0;s<10;s+=2){const a=(s+8)%10,l=(s+2)%10,c=n[l],u=n[l+1],d=ht(c,u,1)^n[a],f=wt(c,u,1)^n[a+1];for(let w=0;w<50;w+=10)e[s+w]^=d,e[s+w+1]^=f}let r=e[2],i=e[3];for(let s=0;s<24;s++){const a=At[s],l=ht(r,i,a),c=wt(r,i,a),u=Tt[s];r=e[u],i=e[u+1],e[u]=l,e[u+1]=c}for(let s=0;s<50;s+=10){for(let a=0;a<10;a++)n[a]=e[s+a];for(let a=0;a<10;a++)e[s+a]^=~n[(a+2)%10]&n[(a+4)%10]}e[0]^=Te[o],e[1]^=Ae[o]}n.fill(0)}class ot extends Se{constructor(t,n,o,r=!1,i=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=n,this.outputLen=o,this.enableXOF=r,this.rounds=i,ct(o),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ie(this.state)}keccak(){dt||ft(this.state32),De(this.state32,this.rounds),dt||ft(this.state32),this.posOut=0,this.pos=0}update(t){lt(this);const{blockLen:n,state:o}=this;t=kt(t);const r=t.length;for(let i=0;i<r;){const s=Math.min(n-this.pos,r-i);for(let a=0;a<s;a++)o[this.pos++]^=t[i++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:o,blockLen:r}=this;t[o]^=n,(n&128)!==0&&o===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){lt(this,!1),nt(t),this.finish();const n=this.state,{blockLen:o}=this;for(let r=0,i=t.length;r<i;){this.posOut>=o&&this.keccak();const s=Math.min(o-this.posOut,i-r);t.set(n.subarray(this.posOut,this.posOut+s),r),this.posOut+=s,r+=s}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return ct(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(de(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:n,suffix:o,outputLen:r,rounds:i,enableXOF:s}=this;return t||(t=new ot(n,o,r,s,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=o,t.outputLen=r,t.enableXOF=s,t.destroyed=this.destroyed,t}}const Re=(e,t,n)=>Ce(()=>new ot(t,e,n)),Rt=Re(1,136,256/8);function Bt(e){const t=Rt(e);return"0x"+Array.from(t.slice(0,4)).map(o=>o.toString(16).padStart(2,"0")).join("")}function vt(e){const t=Rt(e);return"0x"+Array.from(t).map(n=>n.toString(16).padStart(2,"0")).join("")}function Be(e){const t=L(e);if(t.length<64)throw new Error("Result too short for ABI-encoded bytes");const n=t[60]<<24|t[61]<<16|t[62]<<8|t[63];if(t.length<64+n)throw new Error("Result too short for declared length");return t.slice(64,64+n)}function ve(e){const t=e.startsWith("0x")?e.slice(2):e;if(t.length<64+32*64)throw new Error("Result too short for ABI-encoded tuple");const n=BigInt("0x"+t.slice(0,64)),o=[];for(let r=0;r<32;r++){const i=64+r*64,s=i+64;o.push(L(t.slice(i,s)))}return[n,o]}function xe(e){const t=e,n=[];for(let a=0;a<32;a++)n.push(Number(t>>BigInt(a*5)&0x1fn));const o=Number(t>>160n&0x1fn),r=Number(t>>165n&0xffffffffn),i=Number(t>>197n&0xffffffffn),s=Number(t>>229n&0x7ffffffn);return{peakHeights:n,peakCount:o,leafCount:r,previousInsertBlockNumber:i,deployBlockNumber:s}}async function xt(e){function t(y){return parseInt(y.slice(-8),16)}const n=t(e.topics[1]),o=e.data.startsWith("0x")?e.data.slice(2):e.data,r=parseInt(o.slice(56,64),16),i=parseInt(o.slice(64,128),16)*2,s=parseInt(o.slice(128,192),16)*2,a=parseInt(o.slice(i,i+64),16),l=o.slice(i+64,i+64+a*2),c=L(l),u=parseInt(o.slice(s,s+64),16),d=[];let f=s+64;for(let y=0;y<u;y++){const g=o.slice(f,f+64);d.push(L(g)),f+=64}const w=await Promise.all(d.map(async y=>Pt(y)));return{leafIndex:n,previousInsertBlockNumber:r,newData:c,leftInputs:w,blockNumber:e.blockNumber,transactionHash:e.transactionHash,removed:e.removed}}async function rt(e,t,n,o=1){const i=await(await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",method:t,params:n,id:o})})).text();let s;try{s=JSON.parse(i)}catch{throw new Error(`Failed to parse JSON from Ethereum RPC response: ${i}`)}if(s.error)throw console.error("Ethereum RPC error:",JSON.stringify(s.error,null,2)),new Error(s.error.message||JSON.stringify(s.error));return s.result}async function Ft(e,t,n,o="latest"){return rt(e,"eth_call",[{to:t,data:n},o])}async function Fe(e){const{ethereumHttpRpcUrl:t,contractAddress:n,getLatestCidSignatureOverride:o,getLatestCidCalldataOverride:r,blockTag:i}=e,s=i?"0x"+i.toString(16):"latest",l=Bt(o??"getLatestCID()"),u=await Ft(t,n,r??l,s),d=Be(u);return h.decode(Uint8Array.from(d))}async function N(e){try{const{ethereumHttpRpcUrl:t,contractAddress:n,getAccumulatorDataCalldataOverride:o,blockTag:r}=e,i=r?"0x"+r.toString(16):"latest",a=Bt("getAccumulatorData()"),c=await Ft(t,n,o??a,i),[u,d]=ve(c),f=xe(u),g=d.slice(0,f.peakCount).map(Pt).map((I,m)=>({cid:I,height:f.peakHeights[m]}));return{meta:f,peaks:g}}catch(t){throw console.error("][getAccumulatorData] Error:",t),t}}function M(e){return"0x"+e.toString(16)}async function it(e){const{ethereumHttpRpcUrl:t,contractAddress:n,fromBlock:o,toBlock:r,eventTopicOverride:i}=e,s=i??vt("LeafInsert(uint32,uint32,bytes,bytes32[])"),a=await rt(t,"eth_getLogs",[{address:n,topics:[s],fromBlock:M(o),toBlock:M(r)}]);return a.forEach((c,u)=>{const d=c.topics?c.topics[0].toLowerCase():void 0,f=s.toLowerCase();(!c.topics||d!==f)&&console.warn(`[WARN:getLeafInsertLogs] log[${u}].topics[0] does not match eventTopic. topics[0]:`,d,"| eventTopic:",f)}),await Promise.all(a.filter(c=>c.topics&&c.topics[0]&&c.topics[0].toLowerCase()===s.toLowerCase()).map(async c=>await xt(c)))}async function Ne(e){const{ethereumHttpRpcUrl:t,contractAddress:n,fromBlock:o,toBlock:r,targetLeafIndex:i,eventTopicOverride:s}=e,a=s??vt("LeafInsert(uint32,uint32,bytes,bytes32[])"),l="0x"+i.toString(16).padStart(64,"0"),u=await rt(t,"eth_getLogs",[{address:n,topics:[a,l],fromBlock:M(o),toBlock:M(r)}]);if(u.length>1)throw new Error(`Multiple logs found for leaf index ${i} in range ${o}-${r}`);return u.length===0?null:xt(u[0])}function Ue(e){return e instanceof h}function Oe(e){return typeof e=="object"&&e!==null&&"L"in e&&"R"in e&&e.L instanceof h&&e.R instanceof h}async function H(e,t){let n;try{n=await t.getBlock(e)}catch{throw new Error(`Block with CID ${e.toString()} not found in blockstore`)}const o=Xt(n);if(o instanceof Uint8Array)return[o];if(Ue(o))return await H(o,t);if(Oe(o)){const r=await H(o.L,t),i=await H(o.R,t);return[...r,...i]}else throw new Error("Unexpected node structure")}async function Nt(e,t,n,o){const r=o==null?void 0:o.signal;if(r!=null&&r.aborted)throw new DOMException("Aborted","AbortError");let i,s;r&&(s=new Promise((a,l)=>{i=()=>l(new DOMException("Aborted","AbortError")),r.addEventListener("abort",i)}));try{const a=H(n,e),l=await(s?Promise.race([a,s]):a);for(let c=0;c<l.length;c++)await j(t,c,{newData:l[c],__type:"LeafRecord"});return!0}catch{return!1}finally{r&&i&&r.removeEventListener("abort",i)}}function $e(e,t,n,o,r){if(!o){console.log("[Client] ℹ️ rePinAllDataToIPFS skipped because this.shouldPin == false");return}t.get("dag:trail:maxIndex").then(i=>{const s=Number(i??-1);s!==-1&&(async()=>{console.log(`[Client] 📌 Attempting to pin all ${s+1} CIDs (leaves, root, and intermediate nodes) to IPFS. Running in background. Will update you...`);let a=0,l=0;for(let c=0;c<=s;c++)try{const u=await _t(t,c);if(!u)throw new Error(`[Client] Expected CIDDataPair for leaf ${c}`);if(!await Ut(e,n,r,u.cid,u.dagCborEncodedData)){l++;continue}a++,a%1e3===0&&console.log(`[Client] 📌 UPDATE: Re-pinned ${a} CIDs to IPFS so far. Still working...`)}catch(u){console.error("[Client] Error during optimistic IPFS pinning:",u)}console.log(`[Client] 📌 Pinned ${a} CIDs to IPFS (${l} failures). Done!`)})()})}async function Ut(e,t,n,o,r){try{await G(r,o)}catch(i){return console.error("[putPinProvideToIPFS] 💥 CID verification failed:",i,{cid:o,dagCborEncodedData:r}),!1}if(t)try{await e.putBlock(o,r)}catch(i){return console.error(`[Client] 💥 IPFS put failed for CID ${o}:`,i),!1}if(n)try{await e.provide(o)}catch(i){console.error(`[Client] IPFS provide failed for CID ${o}:`,i)}return!0}async function He(e,t,n,o,r,i){let s=n,a=o;const l=[];for(;s>=r;){const c=await Ne({ethereumHttpRpcUrl:e,contractAddress:t,fromBlock:a,toBlock:a,targetLeafIndex:s,eventTopicOverride:i});if(!c)throw new Error(`Missing LeafInsert log for leafIndex=${s} in block=${a}`);if(l.push(c),s===r)break;if(c.leafIndex===void 0||c.previousInsertBlockNumber===void 0)throw new Error(`[walkBackLeafInsertLogsOrThrow] Malformed LeafInsert log at leafIndex ${s}`);if(s=c.leafIndex-1,a=c.previousInsertBlockNumber,s<r)throw new Error(`[walkBackLeafInsertLogsOrThrow] Walkback went past toLeafIndex (${r})`)}return l.reverse()}async function K(e){if(e.length===0)return B;if(e.length===1)return e[0];let t=e[0];for(let n=1;n<e.length;n++){const{cid:o}=await F({L:t,R:e[n]});t=o}return t}async function Me(e,t,n){let o=e.map(a=>({cid:a.cid,height:a.height}));if(e.length==0)return{previousRootCID:B,previousPeaksWithHeights:[]};if(n.length===0){const a=e.filter(c=>c.height!==0);return{previousRootCID:await K(a.map(c=>c.cid)),previousPeaksWithHeights:a}}let r=[...o];for(let a=n.length-1;a>=0;a--){const l=r.pop();if(!l)throw new Error("No mergedPeak to unmerge");const c=l.height-1;r.push({cid:n[a],height:c}),r.push({cid:l.cid,height:c})}const{cid:i}=await F(t);return r=r.filter(a=>!(a.height===0&&a.cid.toString()===i.toString())),{previousRootCID:await K(r.map(a=>a.cid)),previousPeaksWithHeights:r}}async function Ot(e,t,n,o,r,i,s,a=1e3){const{meta:l,peaks:c}=await N({ethereumHttpRpcUrl:n,contractAddress:o,getAccumulatorDataCalldataOverride:i}),u=l.leafCount-1,d=l.previousInsertBlockNumber,f=l.deployBlockNumber;r(l.previousInsertBlockNumber);const w=await t.getHighestContiguousLeafIndexWithData();console.log(`[Client] 🔁 Syncing backwards from block ${l.previousInsertBlockNumber} to block ${l.deployBlockNumber} (${l.previousInsertBlockNumber-l.deployBlockNumber} blocks), grabbing ${a} blocks per RPC call.`),console.log("[Client] 🔎 Simultaneously checking IPFS for older root CIDs as we discover them.");let g=await K(c.map(E=>E.cid)),I=u+1,m=c;const S=[];function k(E){let C=!1,A;return{promise:E.then(U=>(C=!0,A=U,U)),isFulfilled:()=>C,getValue:()=>A}}for(let E=d;E>=f;E-=a){const C=Math.max(f,E-a+1);console.log(`[Client] 📦 Checking blocks ${C} to ${E} for LeafInsert events...`);const A=await it({ethereumHttpRpcUrl:n,contractAddress:o,fromBlock:C,toBlock:E,eventTopicOverride:s});A.length>0&&console.log(`[Client] 🍃 Found ${A.length} LeafInsert events`);for(const p of A.sort((b,D)=>D.leafIndex-b.leafIndex)){if(p.leafIndex!==--I)throw new Error(`[Client] Expected leafIndex ${I} but got leafIndex ${p.leafIndex}`);const{previousRootCID:b,previousPeaksWithHeights:D}=await Me(m,p.newData,p.leftInputs);await j(t,p.leafIndex,{newData:p.newData,event:p,blockNumber:p.blockNumber,rootCid:b,peaksWithHeights:D}),m=D,g=b}const q=new AbortController,U=k(Nt(e,t,g,{signal:q.signal}).catch(p=>{if((p==null?void 0:p.name)==="AbortError")return!1;throw p}));S.push({...U,controller:q,cid:g});const st=S.findIndex(p=>p.isFulfilled()&&p.getValue());if(st!==-1){S.forEach(D=>D.controller.abort());const p=S[st].cid,b=await X(t,u);if(b.length!==0)throw new Error("Unexpectedly missing newData for leaf indices: "+b.join(", "));console.log(`[Client] 📥 Downloaded all data for root CID ${(p==null?void 0:p.toString())??"undefined"} from IPFS.`),console.log("[Client] 🙌 Successfully resolved all remaining data from IPFS!"),console.log("[Client] 🌲 Your accumulator client has acquired all data!"),await t.persist();return}if(I<=w)break}S.forEach(E=>E.controller.abort()),await Promise.allSettled(S.map(E=>E.promise));const T=await X(t,u);if(T.length!==0)throw new Error("[Client] Missing newData for leaf indices: "+T.join(", "));console.log("[Client] 🦾 Fully synced backwards using only event data and local DB data (no data used from IPFS)"),console.log("[Client] 🌲 Your accumulator client has acquired all data!"),await t.persist()}async function We(e,t,n,o,r,i,s,a,l,c,u,d,f,w,y,g,I=1e4){if(a())return;l(!0);let m=!1;r?(console.log(`[Client] 🔗 Detected ETHEREUM_WS_RPC_URL: ${r}`),m=await Ve(r),m||console.log("[Client] ❌ WS endpoint does not support eth_subscribe, falling back to polling.")):console.log("[Client] 👎 No ETHEREUM_WS_RPC_URL provided, will use polling."),console.log(`[Client] 👀 Using ${m?"websocket subscription":"HTTP polling"} to monitor the chain for new data insertions.`),m?Mt({mmr:e,storageAdapter:t,ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,ws:i,setWs:s,getLastProcessedBlock:d,setLastProcessedBlock:f,newLeafEventSubscribers:u,contractAddress:n,getAccumulatorDataCalldataOverride:w,eventTopicOverride:g}):Ht({mmr:e,storageAdapter:t,ethereumHttpRpcUrl:o,contractAddress:n,getLiveSyncRunning:a,setLiveSyncInterval:c,newLeafEventSubscribers:u,getLastProcessedBlock:d,setLastProcessedBlock:f,getAccumulatorDataCalldataOverride:w,getLatestCidCalldataOverride:y,eventTopicOverride:g,pollIntervalMs:I})}function $t(e,t,n,o,r){o(!1),n()&&(clearTimeout(n()),r(void 0)),e&&(e.close(),t(void 0))}async function Ve(e){return!e.startsWith("ws://")&&!e.startsWith("wss://")?(console.log(`[Client] 👎 ETHEREUM_WS_RPC_URL is not a ws:// or wss:// URL: ${e}`),!1):(console.log(`[Client] 🙏 Attempting to open WebSocket and send eth_subscribe to ${e}...`),await new Promise(t=>{let n=null,o=!1;const r=setTimeout(()=>{o||(o=!0,n&&n.close(),t(!1))},3e3);try{n=new WebSocket(e),n.onopen=()=>{const i=JSON.stringify({jsonrpc:"2.0",id:1,method:"eth_subscribe",params:["newHeads"]});n.send(i)},n.onmessage=i=>{try{const s=JSON.parse(i.data);s.id===1&&(s.result||s.error)&&(o||(o=!0,clearTimeout(r),n.close(),t(!s.error)))}catch{}},n.onerror=()=>{o||(o=!0,clearTimeout(r),n.close(),t(!1))},n.onclose=()=>{o||(o=!0,clearTimeout(r),t(!1))}}catch{o||(o=!0,clearTimeout(r),n&&n.close(),t(!1))}}))}function Ht(e){const{mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:r,getLiveSyncRunning:i,setLiveSyncInterval:s,newLeafEventSubscribers:a,getLastProcessedBlock:l,setLastProcessedBlock:c,getAccumulatorDataCalldataOverride:u,getLatestCidCalldataOverride:d,eventTopicOverride:f,pollIntervalMs:w}=e,y=async()=>{try{const g=await N({ethereumHttpRpcUrl:o,contractAddress:r,getAccumulatorDataCalldataOverride:u}),{meta:I}=g,m=I.previousInsertBlockNumber;if(m>l()){const S=await it({ethereumHttpRpcUrl:o,contractAddress:r,fromBlock:l()+1,toBlock:m,eventTopicOverride:f});for(const k of S)await Wt({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:r,event:k,newLeafEventSubscribers:a,getAccumulatorDataCalldataOverride:u,getLatestCidCalldataOverride:d,eventTopicOverride:f});c(m)}}catch(g){console.error("[LiveSync] Error during polling:",g)}i()&&s(setTimeout(y,w??1e4))};y()}function Mt(e){const{mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,ws:i,setWs:s,getLastProcessedBlock:a,setLastProcessedBlock:l,newLeafEventSubscribers:c,contractAddress:u,getAccumulatorDataCalldataOverride:d,eventTopicOverride:f}=e;if(!r){console.error("[Client] No ETHEREUM_WS_RPC_URL set. Cannot start subscription sync.");return}if(i){console.warn("[Client] Subscription WebSocket already running.");return}console.log(`[Client] Connecting to WS: ${r}`);const w=new WebSocket(r);s(w),w.onopen=()=>{console.log("[Client] WebSocket open. Subscribing to newHeads...");const g=JSON.stringify({jsonrpc:"2.0",id:1,method:"eth_subscribe",params:["newHeads"]});w.send(g)};let y=null;w.onmessage=async g=>{try{const I=JSON.parse(g.data);if(I.id===1&&I.result){y=I.result,console.log(`[Client] Subscribed to newHeads. Subscription id: ${y}`);return}if(I.method==="eth_subscription"&&I.params&&I.params.subscription===y){const m=I.params.result.hash;console.log(`[Client] New block: ${m}. Fetching events...`);try{const{meta:S}=await N({ethereumHttpRpcUrl:o,contractAddress:u,getAccumulatorDataCalldataOverride:d}),k=a(),T=S.previousInsertBlockNumber;if(T>k){const E=await it({ethereumHttpRpcUrl:o,contractAddress:u,fromBlock:k+1,toBlock:T,eventTopicOverride:f});for(const C of E)await Wt({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:u,event:C,newLeafEventSubscribers:c,getAccumulatorDataCalldataOverride:d,eventTopicOverride:f});l(T)}}catch(S){console.error("[LiveSync] Error during WS event processing:",S)}}}catch(I){console.error("[Client] Error parsing WS message:",I)}},w.onerror=g=>{console.error("[Client] WebSocket error:",g)},w.onclose=()=>{console.log("[Client] WebSocket closed."),e.setWs(void 0)}}async function Wt(e){const{mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:r,event:i,newLeafEventSubscribers:s,getAccumulatorDataCalldataOverride:a,getLatestCidCalldataOverride:l,eventTopicOverride:c}=e;await Vt(n,o,r,i,s,c),await Gt(t,n,i.leafIndex,i.newData);for(const d of s)d(i.leafIndex,V(i.newData));const{meta:u}=await N({ethereumHttpRpcUrl:o,contractAddress:r,getAccumulatorDataCalldataOverride:a});if(t.leafCount-1===u.leafCount-1)try{const d=await t.rootCIDAsBase32(),f=await Fe({ethereumHttpRpcUrl:o,contractAddress:r,getLatestCidCalldataOverride:l});d!==f.toString()?console.warn(`[Client] 🧠 Sanity check: ❌ Local (${d} )and on-chain (${f.toString()}) root CIDs do NOT match!`):console.log("[Client] 🧠 Sanity check: 😅 Local and on-chain root CIDs match!")}catch(d){console.warn("[Client] 🧠 Sanity check: ❌ Failed to compare root CIDs:",d)}console.log(`[Client] 🍃 Processed new leaf with index ${i.leafIndex}`)}async function Vt(e,t,n,o,r,i){const s=await e.getHighestContiguousLeafIndexWithData();if(!(o.leafIndex<=s)){if(o.leafIndex>s+1){console.log(`[Client] 📌 Missing event for leaf indexes ${s+1} to ${o.leafIndex-1}. Getting them now...`);const a=await He(t,n,o.leafIndex-1,o.previousInsertBlockNumber,s+1,i);for(let l=0;l<a.length;l++)await Vt(e,t,n,a[l],r,i);console.log("[Client] 👍 Got the missing events.")}await j(e,o.leafIndex,re(o))}}async function Gt(e,t,n,o){const r=e.leafCount-1;if(!(n<=r)){if(n>r+1){console.log(`[Client] 📌 Lower indexed leaves ${r+1} to ${n-1} have yet to be processed by the MMR. Processing them now...`);const i=[];for(let s=r+1;s<n;s++){const a=await J(t,s);if(a===void 0)throw new Error(`Missing leaf data for leaf index ${s}`);i.push({leafIndex:s,newData:a.newData})}for(let s=0;s<i.length;s++)await Gt(e,t,i[s].leafIndex,i[s].newData);console.log("[Client] 👍 Processed the missing events in the MMR.")}await Lt(t,e,n,o)}}function Ge(e,t){return e.push(t),()=>{const n=e.indexOf(t);n!==-1&&e.splice(n,1)}}async function je(e){const t={storageAdapter:e,getLeafRecord:async n=>{const o=await J(e,n);return o===void 0?null:o},putLeafRecord:async(n,o)=>{await j(t.storageAdapter,n,o)},getLeafIndexesWithMissingNewData:async()=>{const n=await t.storageAdapter.getHighestContiguousLeafIndexWithData();return X(t.storageAdapter,n)},getCIDDataPairFromDB:n=>_t(t.storageAdapter,n),iterateTrailPairs:()=>ae(t.storageAdapter),get:n=>t.storageAdapter.get(n),put:(n,o)=>t.storageAdapter.put(n,o),delete:n=>t.storageAdapter.delete(n)};return t}function jt(){return typeof window<"u"&&typeof window.document<"u"}function Jt(){return typeof process<"u"&&!!(process.versions&&process.versions.node)}class Y{async getHighestContiguousLeafIndexWithData(){const t=[];for await(const{key:o,value:r}of this.iterate("leaf:")){const i=typeof o=="string"&&o.match(/^leaf:(\d+):newData$/);if(i){const s=parseInt(i[1],10);r!=null&&t.push(s)}}if(t.length===0)return-1;t.sort((o,r)=>o-r);let n=-1;for(let o=0;o<t.length&&t[o]===o;o++)n=o;return n}constructor(t="cid-accumulator",n="kv"){this._instanceId=Y._nextId++,this.dbName=t,this.storeName=n,this.dbPromise=this.openDB()}openDB(){if(typeof indexedDB>"u")throw new Error("IndexedDB is not available in this environment.");return new Promise((t,n)=>{const o=indexedDB.open(this.dbName,1);o.onupgradeneeded=()=>{o.result.createObjectStore(this.storeName)},o.onsuccess=()=>{t(o.result)},o.onerror=()=>{console.error(`[IndexedDBAdapter] onerror (instanceId=${this._instanceId})`,o.error),n(o.error)}})}async withStore(t,n){const o=await this.dbPromise;return new Promise((r,i)=>{const a=o.transaction(this.storeName,t).objectStore(this.storeName),l=n(a);l.onsuccess=()=>r(l.result),l.onerror=()=>i(l.error)})}async get(t){return await this.withStore("readonly",n=>n.get(t))}async put(t,n){await this.withStore("readwrite",o=>o.put(n,t))}async delete(t){await this.withStore("readwrite",n=>n.delete(t))}async*iterate(t){const n=await this.dbPromise;if(!n)throw new Error("IndexedDB database not initialized.");const i=n.transaction(this.storeName,"readonly").objectStore(this.storeName).openCursor(),s=await new Promise((a,l)=>{const c=[];i.onsuccess=()=>{const u=i.result;u?(typeof u.key=="string"&&u.key.startsWith(t)&&c.push({key:u.key,value:u.value}),u.continue()):a(c)},i.onerror=()=>l(i.error)});for(const a of s)yield a}async open(){await this.dbPromise}async persist(){}async close(){}async createIndexByPayloadSlice(t,n){const o=new Map;for await(const{value:r}of this.iterate("leaf:")){const i=r.slice(t,t+n);o.has(i)||o.set(i,[]),o.get(i).push(r)}return o}}Y._nextId=1;async function Je(e){let t;if(jt())t=new Y;else{const n=await tt(()=>import("./JSMapAdapter-iCVOYWjZ.js"),[]);t=new n.JSMapAdapter(e.DB_PATH??"./.db/accumulator.json")}return await je(t)}class Ye{constructor(t,n,o,r,i){this.gatewayUrl=t.replace(/\/?ipfs\/?$/,"").replace(/\/$/,""),this.apiUrl=n==null?void 0:n.replace(/\/$/,""),this.shouldPut=o&&n!==void 0,this.shouldPin=r&&n!==void 0,this.shouldProvide=i&&n!==void 0&&!jt()}async getBlock(t){const n=`${this.gatewayUrl}/ipfs/${t.toString()}`,o=await fetch(n,{method:"GET"});if(!o.ok)throw new Error(`IPFS block/get failed: ${o.status} ${o.statusText}`);const r=new Uint8Array(await o.arrayBuffer());return await G(r,t,"[UniversalIpfsAdapter.getBlock] 🚨 IPFS Gateway returned invalid data!"),r}async putBlock(t,n){if(ie(n,t)||console.warn(`[UniversalIpfsAdapter.putBlock] ‼️ CID/Data pair is invalid. dagCborEncodedData: ${n}, expectedCID: ${t.toString()}`),!this.shouldPut)return;const o=`${this.apiUrl}/api/v0/block/put?format=dag-cbor&mhtype=sha2-256&pin=${this.shouldPin}`,r=new FormData;r.append("data",new Blob([n]));const i=await fetch(o,{method:"POST",body:r});if(!i.ok)throw new Error(`IPFS block/put failed: ${i.status} ${i.statusText}`);const s=await i.json(),a=h.parse(s.Key);a.toString()!==t.toString()&&console.warn(`[UniversalIpfsAdapter.putBlock] ‼️ CID returned by the IPFS API was ${a.toString()} but you expected ${t.toString()}`)}async provide(t){if(!this.shouldProvide)return;const n=`${this.apiUrl}/api/v0/dht/provide?arg=${t.toString()}`;fetch(n).catch(()=>{})}}function qe(e,t,n,o,r){return{ipfsAdapter:e,shouldPut:n,shouldPin:o,shouldProvide:r,getAndResolveCID:(i,s)=>Nt(e,t,i,s),rePinAllDataToIPFS:()=>$e(e,t,n,o,r),putPinProvideToIPFS:({cid:i,dagCborEncodedData:s})=>Ut(e,n,r,i,s)}}async function ze(e,t){const n=new Ye(e.IPFS_GATEWAY_URL,e.IPFS_API_URL,e.IPFS_PUT_IF_POSSIBLE,e.IPFS_PIN_IF_POSSIBLE,e.IPFS_PROVIDE_IF_POSSIBLE);let o=e.IPFS_PUT_IF_POSSIBLE&&e.IPFS_API_URL!==void 0,r=e.IPFS_PIN_IF_POSSIBLE&&e.IPFS_API_URL!==void 0,i=e.IPFS_PROVIDE_IF_POSSIBLE&&e.IPFS_API_URL!==void 0&&Jt();o||(r=!1),r||(i=!1),console.log("[Client] 👀 Checking IPFS Gateway connection...");try{await n.getBlock(B),console.log("[Client] 🔗 Connected to IPFS Gateway.")}catch(a){throw console.error("[Client] ❌ Failed to connect to IPFS Gateway:",a),new Error("Failed to connect to IPFS Gateway. Must abort. See above error.")}if(o){console.log("[Client] 👀 Checking IPFS API connection (attempting to PUT a block)...");try{await n.putBlock(B,R(null)),console.log("[Client] 🔗 Connected to IPFS API and verified it can PUT blocks.")}catch(a){o=!1,r=!1,console.error("[Client] ❌ Failed to connect to IPFS API:",a),console.log("[Client] 🤷‍♂️ Will continue without IPFS API connection (Using IPFS Gateway only).")}}if(i&&o){console.log("[Client] 👀 Checking if IPFS API can provide (advertise) blocks...");try{await n.provide(B),console.log("[Client] 🔗 Connected to IPFS API and verified it can PROVIDE blocks.")}catch(a){i=!1,console.error("[Client] ❌ Failed to verify that the IPFS API can provide (advertise) blocks.",a),console.log("[Client] 🤷‍♂️ Will continue without telling IPFS API to provide (advertise) blocks.")}}const s=qe(n,t,o,r,i);return console.log("[Client] 📜 IPFS Capability Summary:"),console.log("[Client] 📜 Summary: IPFS Gateway connected: YES"),console.log(`[Client] 📜 Summary: IPFS API PUT is set up: ${o?"YES":"NO"}`),console.log(`[Client] 📜 Summary: IPFS API PIN is set up: ${r?"YES":"NO"}`),console.log(`[Client] 📜 Summary: IPFS API PROVIDE is set up: ${i?"YES":"NO"}`),s}function Xe(e,t,n,o,r,i,s,a,l,c,u){let d={ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,contractAddress:i,highestCommittedLeafIndex:-1,lastProcessedBlock:s,liveSyncRunning:!1,liveSyncInterval:void 0,websocket:void 0,newLeafEventSubscribers:[],onNewLeaf:f=>Ge(d.newLeafEventSubscribers,f),startSubscriptionSync:()=>Mt({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,ws:d.websocket,setWs:f=>{d.websocket=f},getLastProcessedBlock:()=>d.lastProcessedBlock,setLastProcessedBlock:f=>{d.lastProcessedBlock=f},newLeafEventSubscribers:d.newLeafEventSubscribers,contractAddress:i,getAccumulatorDataCalldataOverride:a,eventTopicOverride:c}),startPollingSync:()=>Ht({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:i,getLiveSyncRunning:()=>d.liveSyncRunning,setLiveSyncInterval:f=>{d.liveSyncInterval=f},newLeafEventSubscribers:d.newLeafEventSubscribers,getLastProcessedBlock:()=>d.lastProcessedBlock,setLastProcessedBlock:f=>{d.lastProcessedBlock=f},getAccumulatorDataCalldataOverride:a,eventTopicOverride:c}),startLiveSync:()=>We(t,n,i,o,r,d.websocket,f=>{d.websocket=f},()=>d.liveSyncRunning,f=>{d.liveSyncRunning=f},f=>{d.liveSyncInterval=f},d.newLeafEventSubscribers,()=>d.lastProcessedBlock,f=>{d.lastProcessedBlock=f},a,l,c),stopLiveSync:()=>$t(d.websocket,f=>{d.websocket=f},()=>d.liveSyncInterval,f=>{d.liveSyncRunning=f},f=>{d.liveSyncInterval=f}),syncBackwardsFromLatest:()=>Ot(e,n,o,i,f=>{d.lastProcessedBlock=f},a,c,u)};return d}async function Ke(e,t,n,o,r,i,s){console.log("[Client] 👀 Checking Ethereum connection...");let a=0;try{const{meta:c}=await N({ethereumHttpRpcUrl:t.ETHEREUM_HTTP_RPC_URL,contractAddress:e,getAccumulatorDataCalldataOverride:t.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE});console.log(`[Client] 🔗 Connected to Ethereum. Target contract address: ${e}`),a=c.deployBlockNumber-1}catch(c){throw console.error("[Client] ❌ Failed to connect to Ethereum node:",c),new Error("Failed to connect to Ethereum node. See above error.")}return Xe(o.ipfsAdapter,r,n,t.ETHEREUM_HTTP_RPC_URL,t.ETHEREUM_WS_RPC_URL,e,a,i,t.GET_LATEST_CID_CALLDATA_OVERRIDE,s,t.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL??1e3)}async function Qe(e){const t=[];for await(const{key:o,value:r}of e.iterate("leaf:")){const i=o.match(/^leaf:(\d+):newData$/);i&&t.push({index:Number(i[1]),data:r})}const n=JSON.stringify(t,null,2);if(Jt()){const o=await tt(()=>import("./__vite-browser-external-BIHI7g3E.js"),[]),r=`accumulator-data-${Date.now()}.json`;return await o.writeFile(r,n,"utf8"),console.log(`[Client] Accumulator data written to ${r}`),r}else{const o=new Blob([n],{type:"application/json"}),r=URL.createObjectURL(o),i=document.createElement("a");return i.href=r,i.download=`accumulator-data-${Date.now()}.json`,document.body.appendChild(i),i.click(),document.body.removeChild(i),URL.revokeObjectURL(r),i.download}}function Ze(e,t,n){return{getHighestIndex:async()=>t(),getData:async o=>{const r=await e.get(`leaf:${o}:newData`);if(r)return r},getRange:async(o,r)=>{if(o<0&&(o=0),r<0&&(r=0),o>t()&&(o=t()),r>t()&&(r=t()),o>r)return[];const i=[];for(let s=o;s<=r;s++){const a=await e.get(`leaf:${s}:newData`);a&&i.push({index:s,data:a})}return i},subscribe:o=>n(o),downloadAll:async()=>Qe(e),iterate:e.iterate.bind(e,"leaf:"),createIndexByPayloadSlice:e.createIndexByPayloadSlice.bind(e)}}function tn(e,t){console.log(`[Client] ⚙ Config: CONTRACT_ADDRESS: ${e}`),console.log(`[Client] ⚙ Config: ETHEREUM_HTTP_RPC_URL: ${t.ETHEREUM_HTTP_RPC_URL}`),console.log(`[Client] ⚙ Config: ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL: ${t.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL??"undefined"}`),console.log(`[Client] ⚙ Config: ETHEREUM_WS_RPC_URL: ${t.ETHEREUM_WS_RPC_URL??"undefined"}`),console.log(`[Client] ⚙ Config: IPFS_GATEWAY_URL: ${t.IPFS_GATEWAY_URL}`),console.log(`[Client] ⚙ Config: IPFS_API_URL: ${t.IPFS_API_URL??"undefined"}`),console.log(`[Client] ⚙ Config: IPFS_PUT_IF_POSSIBLE: ${t.IPFS_PUT_IF_POSSIBLE}`),console.log(`[Client] ⚙ Config: IPFS_PIN_IF_POSSIBLE: ${t.IPFS_PIN_IF_POSSIBLE}`),console.log(`[Client] ⚙ Config: IPFS_PROVIDE_IF_POSSIBLE: ${t.IPFS_PROVIDE_IF_POSSIBLE}`),console.log(`[Client] ⚙ Config: DB_PATH: ${t.DB_PATH??"undefined"}`),console.log(`[Client] ⚙ Config: GET_LATEST_CID_CALLDATA_OVERRIDE: ${t.GET_LATEST_CID_CALLDATA_OVERRIDE??"undefined"}`),console.log(`[Client] ⚙ Config: GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE: ${t.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE??"undefined"}`),console.log(`[Client] ⚙ Config: LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE: ${t.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE??"undefined"}`)}class en{constructor(t,n){this.contractAddress=t,this.config=n??x,this.mmr=new le,tn(this.contractAddress,this.config)}async init(){this.storage=await Je(this.config),await this.storage.storageAdapter.open();const t=await this.storage.storageAdapter.getHighestContiguousLeafIndexWithData();console.log(`[Client] 📤 Found ${t+1} leafs in DB`),this.ipfs=await ze(this.config,this.storage.storageAdapter),this.ipfs.shouldPin&&this.mmr.subscribeToLeafInsertTrail(n=>{var o;for(const{cid:r,dagCborEncodedData:i}of n)(o=this.ipfs)==null||o.putPinProvideToIPFS({cid:r,dagCborEncodedData:i})}),this.sync=await Ke(this.contractAddress,this.config,this.storage.storageAdapter,this.ipfs,this.mmr,this.config.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE,this.config.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE),this.data=Ze(this.storage.storageAdapter,()=>this.mmr.leafCount-1,this.sync.onNewLeaf.bind(this.sync))}async start(){if(console.log("[Client] 🚀 Starting AccumulatorClient..."),await this.init(),!this.ipfs||!this.sync||!this.storage)throw new Error("Not all namespaces present. This should never happen.");await Ot(this.ipfs.ipfsAdapter,this.storage.storageAdapter,this.sync.ethereumHttpRpcUrl,this.sync.contractAddress,t=>this.sync.lastProcessedBlock=t,this.config.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE,this.config.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE,this.config.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL??1e3),ce(this.mmr,this.storage.storageAdapter),this.sync.startLiveSync(),console.log("[Client] 🟢 Client is ready to use.")}async shutdown(){if(!this.sync||!this.ipfs||!this.storage)throw new Error("Not all namespaces present. This should never happen.");console.log("[Client] 👋 Shutting down gracefully."),$t(this.sync.websocket,t=>this.sync.websocket=t,()=>this.sync.liveSyncInterval,t=>this.sync.liveSyncRunning=t,t=>this.sync.liveSyncInterval=t),await this.storage.storageAdapter.close(),console.log("[Client] 🏁 Done.")}}window.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("sync-state"),t=document.getElementById("monitor-state");e&&(e.innerHTML="&nbsp;"),t&&(t.textContent="",t.style.display="none")});const nn=document.getElementById("client-form");function Q(e){const t=document.getElementById("live-events");if(!t)return;const o=`[${new Date().toLocaleTimeString()}] ${e}`;t.textContent=t.textContent?t.textContent+`
`+o:o,t.scrollTop=t.scrollHeight}nn.addEventListener("submit",async e=>{e.preventDefault();const t=document.getElementById("contract-address").value,n={...x,ETHEREUM_HTTP_RPC_URL:document.getElementById("eth-http-url").value||x.ETHEREUM_HTTP_RPC_URL,IPFS_GATEWAY_URL:document.getElementById("ipfs-gateway-url").value||x.IPFS_GATEWAY_URL,IPFS_API_URL:document.getElementById("ipfs-api-url").value||x.IPFS_API_URL},o=document.getElementById("sync-state"),r=document.getElementById("monitor-state"),i=document.getElementById("client-started-indicator");i&&(i.style.display="inline"),o&&(o.textContent="🔄 Syncing backwards..."),r&&(r.textContent="",r.style.display="none");try{const s=new en(t,n);window.client=s,await window.client.start(),o&&(o.textContent="🟢 Synced");const a=document.getElementById("download-data-btn");a&&(a.disabled=!1),window.client.data.subscribe((l,c)=>{const u=`New data: index: ${l}, bytes: ${c}`;Q(u)}),r&&(r.style.display="inline"),window._liveSyncPoll&&clearInterval(window._liveSyncPoll),window._liveSyncPoll=setInterval(()=>{if(!window.client||!window.client.sync)return;const l=window.client.sync.liveSyncRunning,c=document.getElementById("live-events-container");r&&(r.textContent=l?"🟢 Monitoring blockchain for new events":"🔴 Not monitoring blockchain for new events",c&&(c.style.display=l?"block":"none"))},1e3)}catch(s){console.error("Error:",s)}});const $=document.getElementById("download-data-btn");$&&$.addEventListener("click",async()=>{if(!window.client||!window.client.data){console.error("Client not initialized.");return}$.disabled=!0;try{await window.client.data.downloadAll(),Q("Downloaded all data.")}catch(e){console.error("Download error:",e),Q("Error downloading data. See console.")}finally{$.disabled=!1}});export{tt as _};
