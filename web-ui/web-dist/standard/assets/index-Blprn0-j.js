(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))o(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&o(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function o(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();const I={ETHEREUM_HTTP_RPC_URL:"https://ethereum-rpc.publicnode.com",ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL:void 0,ETHEREUM_WS_RPC_URL:void 0,IPFS_GATEWAY_URL:"https://dweb.link",IPFS_API_URL:void 0,IPFS_PUT_IF_POSSIBLE:!0,IPFS_PIN_IF_POSSIBLE:!0,IPFS_PROVIDE_IF_POSSIBLE:!0,DB_PATH:void 0,GET_LATEST_CID_CALLDATA_OVERRIDE:void 0,GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE:void 0,LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE:void 0};var gt;const q="abcdefghijklmnopqrstuvwxyz234567";function Yt(e){let t=0,n=0,o="";for(let r=0;r<e.length;r++)for(n=n<<8|e[r],t+=8;t>=5;)o+=q[n>>>t-5&31],t-=5;return t>0&&(o+=q[n<<5-t&31]),o}function Xt(e){let t=0,n=0,o=[];e=e.toLowerCase().replace(/=+$/,"");for(let r=0;r<e.length;r++)n=n<<5|q.indexOf(e[r]),t+=5,t>=8&&(o.push(n>>>t-8&255),t-=8);return new Uint8Array(o)}class h{get asCID(){return this}get byteLength(){return this.bytes.length}get byteOffset(){return 0}constructor(t,n,o,r){this[gt]="CID",this.version=t,this.code=n,this.multihash=o,this.bytes=r||h.encodeBytes(t,n,o.bytes)}equals(t){return t&&this.toString()===t.toString()}link(){return this}toJSON(){return{"/":this.toString()}}toString(t){return t&&typeof t.encode=="function"?t.encode(this.bytes):"b"+Yt(this.bytes)}toV0(){throw new Error("toV0 not supported in this minimal CID")}toV1(){if(this.version===1)return this;throw new Error("Only v1 supported in this minimal CID")}static asCID(t){return t&&t instanceof h?t:null}static create(t,n,o){return new h(t,n,o)}static createV0(t){throw new Error("CIDv0 not supported in this minimal CID")}static createV1(t,n){return new h(1,t,n)}static decode(t){if(t[0]===1){const o=h.readVarint(t,1),s=1+h.varintLength(t,1),i=h.decodeMultihash(t.slice(s));return new h(1,o.value,i,t)}throw new Error("Only CIDv1 supported")}static decodeFirst(t){const n=h.decode(t);return[n,n.bytes.length]}static equals(t,n){return t&&n&&t.toString()===n.toString()}static inspectBytes(t){return{version:t[0],codec:t[1],multihashCode:t[2]}}static parse(t){if(t[0]!=="b")throw new Error('CID string must be base32 (start with "b")');const n=Xt(t.slice(1));return h.decode(n)}static encodeBytes(t,n,o){return new Uint8Array([t,n,...o])}static readVarint(t,n){return{value:t[n],length:1}}static varintLength(t,n){return 1}static decodeMultihash(t){const n=t[0],o=t[1],r=t.slice(2,2+o),s=t.slice(0,2+o);return{code:n,digest:r,size:o,bytes:s}}}gt=Symbol.toStringTag;const wt=0,pt=1,It=2,Et=3,yt=4,mt=5,Ct=6,qt=7;function L(e,t){if(e<24)return new Uint8Array([t<<5|e]);if(e<256)return new Uint8Array([t<<5|24,e]);if(e<65536)return new Uint8Array([t<<5|25,e>>8,e&255]);if(e<4294967296)return new Uint8Array([t<<5|26,e>>>24&255,e>>>16&255,e>>>8&255,e&255]);throw new Error("Bigint not supported")}function T(...e){let t=e.reduce((r,s)=>r+s.length,0),n=new Uint8Array(t),o=0;for(const r of e)n.set(r,o),o+=r.length;return n}function v(e){if(e===null)return new Uint8Array([246]);if(e===!1)return new Uint8Array([244]);if(e===!0)return new Uint8Array([245]);if(typeof e=="number"){if(Number.isInteger(e))return e>=0?L(e,wt):L(-(e+1),pt);{const t=new ArrayBuffer(9),n=new DataView(t);return n.setUint8(0,251),n.setFloat64(1,e),new Uint8Array(t)}}if(typeof e=="string"){const t=new TextEncoder().encode(e);return T(L(t.length,Et),t)}if(e instanceof Uint8Array)return T(L(e.length,It),e);if(Array.isArray(e)){const t=e.map(v);return T(L(e.length,yt),...t)}if(e instanceof h){const t=L(42,Ct);let n;if(e.bytes instanceof Uint8Array)n=e.bytes;else{const r=h.asCID(e);if(!r)throw new Error("Invalid CID object passed to dagCbor encode");n=r.bytes}const o=T(new Uint8Array([0]),n);return T(t,v(o))}if(typeof e=="object"){const t=Object.keys(e),n=t.map(o=>T(v(o),v(e[o])));return T(L(t.length,mt),...n)}throw new Error("Unsupported type for dag-cbor encode")}function Kt(e){let t=0;function n(){if(t>=e.length)throw new Error("Unexpected end of data");const r=e[t++],s=r>>5,i=r&31;let a=i;if(i>=24)if(i===24)a=e[t++];else if(i===25)a=e[t++]<<8|e[t++];else if(i===26)a=e[t++]<<24|e[t++]<<16|e[t++]<<8|e[t++];else throw new Error("Unsupported int size");switch(s){case wt:return a;case pt:return-1-a;case It:{const l=e.slice(t,t+a);return t+=a,l}case Et:{const l=new TextDecoder().decode(e.slice(t,t+a));return t+=a,l}case yt:{const l=[];for(let c=0;c<a;c++)l.push(n());return l}case mt:{const l={};for(let c=0;c<a;c++){const u=n();l[u]=n()}return l}case Ct:if(a===42){const l=n();if(!(l instanceof Uint8Array)||l[0]!==0)throw new Error("Invalid CID tag");return h.decode(l.slice(1))}else throw new Error("Unsupported CBOR tag: "+a);case qt:if(i===20)return!1;if(i===21)return!0;if(i===22)return null;if(i===23)return;if(i===27){const l=new DataView(e.buffer,e.byteOffset+t,8).getFloat64(0);return t+=8,l}throw new Error("Unsupported CBOR simple value: "+i)}}const o=n();if(t!==e.length)throw new Error("Extra bytes after CBOR decode");return o}const Q=113,zt="modulepreload",Qt=function(e){return"/"+e},it={},Z=function(t,n,o){let r=Promise.resolve();if(n&&n.length>0){let i=function(c){return Promise.all(c.map(u=>Promise.resolve(u).then(d=>({status:"fulfilled",value:d}),d=>({status:"rejected",reason:d}))))};document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),l=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));r=i(n.map(c=>{if(c=Qt(c),c in it)return;it[c]=!0;const u=c.endsWith(".css"),d=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${d}`))return;const f=document.createElement("link");if(f.rel=u?"stylesheet":zt,u||(f.as="script"),f.crossOrigin="",f.href=c,l&&f.setAttribute("nonce",l),document.head.appendChild(f),u)return new Promise((g,E)=>{f.addEventListener("load",g),f.addEventListener("error",()=>E(new Error(`Unable to preload CSS for ${c}`)))})}))}function s(i){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i}return r.then(i=>{for(const a of i||[])a.status==="rejected"&&s(a.reason);return t().catch(s)})};async function tt(e){var t,n;if(typeof window<"u"&&((t=window.crypto)!=null&&t.subtle)){const o=await window.crypto.subtle.digest("SHA-256",e);return new Uint8Array(o)}if(typeof process<"u"&&((n=process.versions)!=null&&n.node)){const{createHash:o}=await Z(async()=>{const{createHash:s}=await import("./__vite-browser-external-BIHI7g3E.js");return{createHash:s}},[]),r=o("sha256");return r.update(Buffer.from(e)),new Uint8Array(r.digest())}throw new Error("No suitable crypto implementation found")}function W(e,t){const n=new Uint8Array([e,t.length,...t]);return{code:e,digest:t,size:32,bytes:n}}async function F(e){const t=v(e),n=await tt(t),o=W(18,n);return{cid:h.createV1(Q,o),dagCborEncodedData:t}}function Zt(e){return JSON.stringify({cid:e.cid.toString(),dagCborEncodedData:G(e.dagCborEncodedData)})}async function _t(e){const{cid:t,dagCborEncodedData:n}=JSON.parse(e);return{cid:h.parse(t),dagCborEncodedData:A(n)}}function St(e){const t=W(18,e);return h.create(1,113,t)}function G(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}function A(e){const t=e.startsWith("0x")?e.slice(2):e;if(t.length%2!==0)throw new Error("Hex string must have even length");const n=new Uint8Array(t.length/2);for(let o=0;o<t.length;o+=2)n[o/2]=parseInt(t.slice(o,o+2),16);return n}function te(e){return JSON.stringify({leafIndex:e.leafIndex,previousInsertBlockNumber:e.previousInsertBlockNumber,newData:G(e.newData),leftInputs:e.leftInputs.map(t=>t.toString()),blockNumber:e.blockNumber,transactionHash:e.transactionHash,removed:e.removed})}function ee(e){return JSON.stringify(e.map(t=>({cid:t.cid.toString(),height:t.height})))}async function ne(e){const t=JSON.parse(e);return Promise.all(t.map(async n=>({cid:h.parse(n.cid),height:n.height})))}function oe(e){const t=JSON.parse(e);return{leafIndex:t.leafIndex,previousInsertBlockNumber:t.previousInsertBlockNumber,newData:A(t.newData),leftInputs:t.leftInputs.map(n=>h.parse(n)),blockNumber:t.blockNumber,transactionHash:t.transactionHash,removed:t.removed}}function re(e){return{newData:e.newData,event:e,blockNumber:e.blockNumber}}async function se(e,t){const n=await tt(e),o=W(18,n);return h.createV1(Q,o).toString()===t.toString()}async function V(e,t,n){const o=await tt(e),r=W(18,o),s=h.createV1(Q,r),i=n??`[Client] 💥 CID/Data pair is invalid. dagCborEncodedData: ${e}, expectedCID: ${t.toString()}, computed(actual)CID: ${s.toString()}`;if(s.toString()!==t.toString())throw new Error(i)}async function j(e,t,n){await e.put(`leaf:${t}:newData`,G(n.newData)),n.event!==void 0&&await e.put(`leaf:${t}:event`,te(n.event)),n.blockNumber!==void 0&&await e.put(`leaf:${t}:blockNumber`,n.blockNumber.toString()),n.rootCid!==void 0&&await e.put(`leaf:${t}:rootCid`,n.rootCid.toString()),n.peaksWithHeights!==void 0&&await e.put(`leaf:${t}:peaksWithHeights`,ee(n.peaksWithHeights))}async function J(e,t){const n=await e.get(`leaf:${t}:newData`);if(n==null)return;const o=A(n),r=await e.get(`leaf:${t}:event`),s=r!==void 0?oe(r):void 0,i=await e.get(`leaf:${t}:blockNumber`),a=i!==void 0?parseInt(i,10):void 0,l=await e.get(`leaf:${t}:rootCid`),c=l!==void 0?h.parse(l):void 0,u=await e.get(`leaf:${t}:peaksWithHeights`),d=u!==void 0?await ne(u):void 0;return{newData:o,event:s,blockNumber:a,rootCid:c,peaksWithHeights:d}}async function K(e,t){const n=[];for(let o=0;o<=t;o++){const r=await J(e,o);(!r||!(r.newData instanceof Uint8Array))&&n.push(o)}return n}async function ie(e,t){let n=Number(await e.get("dag:trail:maxIndex")??-1);for(const o of t){try{await V(o.dagCborEncodedData,o.cid)}catch(a){console.warn("[appendTrailToDB] 💥 CID verification failed:",a,o);continue}const s=`cid:${o.cid.toString()}`;await e.get(s)||(n++,await e.put(`dag:trail:index:${n}`,Zt(o)),await e.put(s,"1"))}await e.put("dag:trail:maxIndex",n.toString())}async function Pt(e,t){const n=await e.get(`dag:trail:index:${t}`);if(n&&typeof n=="string"){const o=await _t(n);return await V(o.dagCborEncodedData,o.cid),o}return null}async function*ae(e){for await(const{value:t}of e.iterate("dag:trail:index:"))t&&typeof t=="string"&&(yield _t(t))}async function bt(e,t,n,o){const r=await t.addLeafWithTrail(n,o);await ie(e,r)}async function ce(e,t){console.log("[Client] ⛰️ Rebuilding the Merkle Mountain Range from synced leaves. (Runs in background).");const n=e.leafCount,o=await t.getHighestContiguousLeafIndexWithData();if(n>o)throw new Error(`[Client] Expected to commit leaves from ${n} to ${o}, but found no newData for leaf ${n}`);if(n!==o){for(let r=n;r<=o;r++){const s=await J(t,r);if(!s||!s.newData)throw new Error(`[Client] Expected newData for leaf ${r}`);if(!(s.newData instanceof Uint8Array))throw new Error(`[Client] newData for leaf ${r} is not a Uint8Array`);await bt(t,e,r,s.newData)}console.log(`[Client] 🎉 Fully rebuilt the Merkle Mountain Range up to leaf index ${o}`),await t.persist()}}const x=h.parse("bafyreifqwkmiw256ojf2zws6tzjeonw6bpd5vza4i22ccpcq4hjv2ts7cm");class le{constructor(){this.peaks=[],this.leafCount=0,this.leafInsertTrailSubscribers=[]}subscribeToLeafInsertTrail(t){return this.leafInsertTrailSubscribers.push(t),()=>{const n=this.leafInsertTrailSubscribers.indexOf(t);n!==-1&&this.leafInsertTrailSubscribers.splice(n,1)}}async addLeafWithTrail(t,n){if(this.leafCount!==t)throw new Error(`Expected leafIndex ${this.leafCount} but got ${t}`);const o=[],{cid:r,dagCborEncodedData:s}=await F(n);o.push({cid:r,dagCborEncodedData:s});let i=r,a=0;for(;this.leafCount>>a&1;){const c=this.peaks.pop();if(!c)throw new Error("MMR structure error: no peak to merge");const{cid:u,dagCborEncodedData:d}=await F({L:c,R:i});o.push({cid:u,dagCborEncodedData:d}),i=u,a++}this.peaks.push(i),this.leafCount++;const l=await this.rootCIDWithTrail();o.push(...l.trail);for(const c of this.leafInsertTrailSubscribers)try{c(o)}catch(u){console.error("[MMR] Error in leafInsertTrail subscriber:",u)}return o}async rootCIDWithTrail(){const t=[];if(this.peaks.length===0)return{root:x,trail:[]};if(this.peaks.length===1)return{root:this.peaks[0],trail:[]};let n=this.peaks[0];for(let o=1;o<this.peaks.length;o++){const{cid:r,dagCborEncodedData:s}=await F({L:n,R:this.peaks[o]});t.push({cid:r,dagCborEncodedData:s}),n=r}return{root:n,trail:t}}async rootCID(){return(await this.rootCIDWithTrail()).root}async rootCIDAsBase32(){return(await this.rootCID()).toString()}}function at(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function ue(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function et(e,...t){if(!ue(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function ct(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function de(e,t){et(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const H=BigInt(2**32-1),lt=BigInt(32);function fe(e,t=!1){return t?{h:Number(e&H),l:Number(e>>lt&H)}:{h:Number(e>>lt&H)|0,l:Number(e&H)|0}}function he(e,t=!1){let n=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:s,l:i}=fe(e[r],t);[n[r],o[r]]=[s,i]}return[n,o]}const ge=(e,t,n)=>e<<n|t>>>32-n,we=(e,t,n)=>t<<n|e>>>32-n,pe=(e,t,n)=>t<<n-32|e>>>64-n,Ie=(e,t,n)=>e<<n-32|t>>>64-n;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ee(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}const ut=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function ye(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function dt(e){for(let t=0;t<e.length;t++)e[t]=ye(e[t])}typeof Uint8Array.from([]).toHex=="function"&&Uint8Array.fromHex;function me(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function Lt(e){return typeof e=="string"&&(e=me(e)),et(e),e}class Ce{clone(){return this._cloneInto()}}function _e(e){const t=o=>e().update(Lt(o)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}const Tt=[],At=[],Rt=[],Se=BigInt(0),U=BigInt(1),Pe=BigInt(2),be=BigInt(7),Le=BigInt(256),Te=BigInt(113);for(let e=0,t=U,n=1,o=0;e<24;e++){[n,o]=[o,(2*n+3*o)%5],Tt.push(2*(5*o+n)),At.push((e+1)*(e+2)/2%64);let r=Se;for(let s=0;s<7;s++)t=(t<<U^(t>>be)*Te)%Le,t&Pe&&(r^=U<<(U<<BigInt(s))-U);Rt.push(r)}const[Ae,Re]=he(Rt,!0),ft=(e,t,n)=>n>32?pe(e,t,n):ge(e,t,n),ht=(e,t,n)=>n>32?Ie(e,t,n):we(e,t,n);function ke(e,t=24){const n=new Uint32Array(10);for(let o=24-t;o<24;o++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,l=(i+2)%10,c=n[l],u=n[l+1],d=ft(c,u,1)^n[a],f=ht(c,u,1)^n[a+1];for(let g=0;g<50;g+=10)e[i+g]^=d,e[i+g+1]^=f}let r=e[2],s=e[3];for(let i=0;i<24;i++){const a=At[i],l=ft(r,s,a),c=ht(r,s,a),u=Tt[i];r=e[u],s=e[u+1],e[u]=l,e[u+1]=c}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)n[a]=e[i+a];for(let a=0;a<10;a++)e[i+a]^=~n[(a+2)%10]&n[(a+4)%10]}e[0]^=Ae[o],e[1]^=Re[o]}n.fill(0)}class nt extends Ce{constructor(t,n,o,r=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=n,this.outputLen=o,this.enableXOF=r,this.rounds=s,at(o),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ee(this.state)}keccak(){ut||dt(this.state32),ke(this.state32,this.rounds),ut||dt(this.state32),this.posOut=0,this.pos=0}update(t){ct(this);const{blockLen:n,state:o}=this;t=Lt(t);const r=t.length;for(let s=0;s<r;){const i=Math.min(n-this.pos,r-s);for(let a=0;a<i;a++)o[this.pos++]^=t[s++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:o,blockLen:r}=this;t[o]^=n,(n&128)!==0&&o===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){ct(this,!1),et(t),this.finish();const n=this.state,{blockLen:o}=this;for(let r=0,s=t.length;r<s;){this.posOut>=o&&this.keccak();const i=Math.min(o-this.posOut,s-r);t.set(n.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return at(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(de(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:n,suffix:o,outputLen:r,rounds:s,enableXOF:i}=this;return t||(t=new nt(n,o,r,i,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=o,t.outputLen=r,t.enableXOF=i,t.destroyed=this.destroyed,t}}const De=(e,t,n)=>_e(()=>new nt(t,e,n)),kt=De(1,136,256/8);function Dt(e){const t=kt(e);return"0x"+Array.from(t.slice(0,4)).map(o=>o.toString(16).padStart(2,"0")).join("")}function Bt(e){const t=kt(e);return"0x"+Array.from(t).map(n=>n.toString(16).padStart(2,"0")).join("")}function Be(e){const t=A(e);if(t.length<64)throw new Error("Result too short for ABI-encoded bytes");const n=t[60]<<24|t[61]<<16|t[62]<<8|t[63];if(t.length<64+n)throw new Error("Result too short for declared length");return t.slice(64,64+n)}function ve(e){const t=e.startsWith("0x")?e.slice(2):e;if(t.length<64+32*64)throw new Error("Result too short for ABI-encoded tuple");const n=BigInt("0x"+t.slice(0,64)),o=[];for(let r=0;r<32;r++){const s=64+r*64,i=s+64;o.push(A(t.slice(s,i)))}return[n,o]}function xe(e){const t=e,n=[];for(let a=0;a<32;a++)n.push(Number(t>>BigInt(a*5)&0x1fn));const o=Number(t>>160n&0x1fn),r=Number(t>>165n&0xffffffffn),s=Number(t>>197n&0xffffffffn),i=Number(t>>229n&0x7ffffffn);return{peakHeights:n,peakCount:o,leafCount:r,previousInsertBlockNumber:s,deployBlockNumber:i}}async function vt(e){function t(E){return parseInt(E.slice(-8),16)}const n=t(e.topics[1]),o=e.data.startsWith("0x")?e.data.slice(2):e.data,r=parseInt(o.slice(56,64),16),s=parseInt(o.slice(64,128),16)*2,i=parseInt(o.slice(128,192),16)*2,a=parseInt(o.slice(s,s+64),16),l=o.slice(s+64,s+64+a*2),c=A(l),u=parseInt(o.slice(i,i+64),16),d=[];let f=i+64;for(let E=0;E<u;E++){const w=o.slice(f,f+64);d.push(A(w)),f+=64}const g=await Promise.all(d.map(async E=>St(E)));return{leafIndex:n,previousInsertBlockNumber:r,newData:c,leftInputs:g,blockNumber:e.blockNumber,transactionHash:e.transactionHash,removed:e.removed}}async function ot(e,t,n,o=1){const s=await(await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",method:t,params:n,id:o})})).text();let i;try{i=JSON.parse(s)}catch{throw new Error(`Failed to parse JSON from Ethereum RPC response: ${s}`)}if(i.error)throw console.error("Ethereum RPC error:",JSON.stringify(i.error,null,2)),new Error(i.error.message||JSON.stringify(i.error));return i.result}async function xt(e,t,n,o="latest"){return ot(e,"eth_call",[{to:t,data:n},o])}async function Ue(e){const{ethereumHttpRpcUrl:t,contractAddress:n,getLatestCidSignatureOverride:o,getLatestCidCalldataOverride:r,blockTag:s}=e,i=s?"0x"+s.toString(16):"latest",l=Dt(o??"getLatestCID()"),u=await xt(t,n,r??l,i),d=Be(u);return h.decode(Uint8Array.from(d))}async function N(e){try{const{ethereumHttpRpcUrl:t,contractAddress:n,getAccumulatorDataCalldataOverride:o,blockTag:r}=e,s=r?"0x"+r.toString(16):"latest",a=Dt("getAccumulatorData()"),c=await xt(t,n,o??a,s),[u,d]=ve(c),f=xe(u),w=d.slice(0,f.peakCount).map(St).map((y,m)=>({cid:y,height:f.peakHeights[m]}));return{meta:f,peaks:w}}catch(t){throw console.error("][getAccumulatorData] Error:",t),t}}function M(e){return"0x"+e.toString(16)}async function rt(e){const{ethereumHttpRpcUrl:t,contractAddress:n,fromBlock:o,toBlock:r,eventTopicOverride:s}=e,i=s??Bt("LeafInsert(uint32,uint32,bytes,bytes32[])"),a=await ot(t,"eth_getLogs",[{address:n,topics:[i],fromBlock:M(o),toBlock:M(r)}]);return a.forEach((c,u)=>{const d=c.topics?c.topics[0].toLowerCase():void 0,f=i.toLowerCase();(!c.topics||d!==f)&&console.warn(`[WARN:getLeafInsertLogs] log[${u}].topics[0] does not match eventTopic. topics[0]:`,d,"| eventTopic:",f)}),await Promise.all(a.filter(c=>c.topics&&c.topics[0]&&c.topics[0].toLowerCase()===i.toLowerCase()).map(async c=>await vt(c)))}async function Fe(e){const{ethereumHttpRpcUrl:t,contractAddress:n,fromBlock:o,toBlock:r,targetLeafIndex:s,eventTopicOverride:i}=e,a=i??Bt("LeafInsert(uint32,uint32,bytes,bytes32[])"),l="0x"+s.toString(16).padStart(64,"0"),u=await ot(t,"eth_getLogs",[{address:n,topics:[a,l],fromBlock:M(o),toBlock:M(r)}]);if(u.length>1)throw new Error(`Multiple logs found for leaf index ${s} in range ${o}-${r}`);return u.length===0?null:vt(u[0])}function Ne(e){return e instanceof h}function Oe(e){return typeof e=="object"&&e!==null&&"L"in e&&"R"in e&&e.L instanceof h&&e.R instanceof h}async function $(e,t){let n;try{n=await t.getBlock(e)}catch{throw new Error(`Block with CID ${e.toString()} not found in blockstore`)}const o=Kt(n);if(o instanceof Uint8Array)return[o];if(Ne(o))return await $(o,t);if(Oe(o)){const r=await $(o.L,t),s=await $(o.R,t);return[...r,...s]}else throw new Error("Unexpected node structure")}async function Ut(e,t,n,o){const r=o==null?void 0:o.signal;if(r!=null&&r.aborted)throw new DOMException("Aborted","AbortError");let s,i;r&&(i=new Promise((a,l)=>{s=()=>l(new DOMException("Aborted","AbortError")),r.addEventListener("abort",s)}));try{const a=$(n,e),l=await(i?Promise.race([a,i]):a);for(let c=0;c<l.length;c++)await j(t,c,{newData:l[c],__type:"LeafRecord"});return!0}catch{return!1}finally{r&&s&&r.removeEventListener("abort",s)}}function He(e,t,n,o,r){if(!o){console.log("[Client] ℹ️ rePinAllDataToIPFS skipped because this.shouldPin == false");return}t.get("dag:trail:maxIndex").then(s=>{const i=Number(s??-1);i!==-1&&(async()=>{console.log(`[Client] 📌 Attempting to pin all ${i+1} CIDs (leaves, root, and intermediate nodes) to IPFS. Running in background. Will update you...`);let a=0,l=0;for(let c=0;c<=i;c++)try{const u=await Pt(t,c);if(!u)throw new Error(`[Client] Expected CIDDataPair for leaf ${c}`);if(!await Ft(e,n,r,u.cid,u.dagCborEncodedData)){l++;continue}a++,a%1e3===0&&console.log(`[Client] 📌 UPDATE: Re-pinned ${a} CIDs to IPFS so far. Still working...`)}catch(u){console.error("[Client] Error during optimistic IPFS pinning:",u)}console.log(`[Client] 📌 Pinned ${a} CIDs to IPFS (${l} failures). Done!`)})()})}async function Ft(e,t,n,o,r){try{await V(r,o)}catch(s){return console.error("[putPinProvideToIPFS] 💥 CID verification failed:",s,{cid:o,dagCborEncodedData:r}),!1}if(t)try{await e.putBlock(o,r)}catch(s){return console.error(`[Client] 💥 IPFS put failed for CID ${o}:`,s),!1}if(n)try{await e.provide(o)}catch(s){console.error(`[Client] IPFS provide failed for CID ${o}:`,s)}return!0}async function $e(e,t,n,o,r,s){let i=n,a=o;const l=[];for(;i>=r;){const c=await Fe({ethereumHttpRpcUrl:e,contractAddress:t,fromBlock:a,toBlock:a,targetLeafIndex:i,eventTopicOverride:s});if(!c)throw new Error(`Missing LeafInsert log for leafIndex=${i} in block=${a}`);if(l.push(c),i===r)break;if(c.leafIndex===void 0||c.previousInsertBlockNumber===void 0)throw new Error(`[walkBackLeafInsertLogsOrThrow] Malformed LeafInsert log at leafIndex ${i}`);if(i=c.leafIndex-1,a=c.previousInsertBlockNumber,i<r)throw new Error(`[walkBackLeafInsertLogsOrThrow] Walkback went past toLeafIndex (${r})`)}return l.reverse()}async function z(e){if(e.length===0)return x;if(e.length===1)return e[0];let t=e[0];for(let n=1;n<e.length;n++){const{cid:o}=await F({L:t,R:e[n]});t=o}return t}async function Me(e,t,n){let o=e.map(a=>({cid:a.cid,height:a.height}));if(e.length==0)return{previousRootCID:x,previousPeaksWithHeights:[]};if(n.length===0){const a=e.filter(c=>c.height!==0);return{previousRootCID:await z(a.map(c=>c.cid)),previousPeaksWithHeights:a}}let r=[...o];for(let a=n.length-1;a>=0;a--){const l=r.pop();if(!l)throw new Error("No mergedPeak to unmerge");const c=l.height-1;r.push({cid:n[a],height:c}),r.push({cid:l.cid,height:c})}const{cid:s}=await F(t);return r=r.filter(a=>!(a.height===0&&a.cid.toString()===s.toString())),{previousRootCID:await z(r.map(a=>a.cid)),previousPeaksWithHeights:r}}async function Nt(e,t,n,o,r,s,i,a=1e3){const{meta:l,peaks:c}=await N({ethereumHttpRpcUrl:n,contractAddress:o,getAccumulatorDataCalldataOverride:s}),u=l.leafCount-1,d=l.previousInsertBlockNumber,f=l.deployBlockNumber;r(l.previousInsertBlockNumber);const g=await t.getHighestContiguousLeafIndexWithData();console.log(`[Client] 🔁 Syncing backwards from block ${l.previousInsertBlockNumber} to block ${l.deployBlockNumber} (${l.previousInsertBlockNumber-l.deployBlockNumber} blocks), grabbing ${a} blocks per RPC call.`),console.log("[Client] 🔎 Simultaneously checking IPFS for older root CIDs as we discover them.");let w=await z(c.map(C=>C.cid)),y=u+1,m=c;const _=[];function R(C){let P=!1,D;return{promise:C.then(O=>(P=!0,D=O,O)),isFulfilled:()=>P,getValue:()=>D}}for(let C=d;C>=f;C-=a){const P=Math.max(f,C-a+1);console.log(`[Client] 📦 Checking blocks ${P} to ${C} for LeafInsert events...`);const D=await rt({ethereumHttpRpcUrl:n,contractAddress:o,fromBlock:P,toBlock:C,eventTopicOverride:i});D.length>0&&console.log(`[Client] 🍃 Found ${D.length} LeafInsert events`);for(const p of D.sort((b,B)=>B.leafIndex-b.leafIndex)){if(p.leafIndex!==--y)throw new Error(`[Client] Expected leafIndex ${y} but got leafIndex ${p.leafIndex}`);const{previousRootCID:b,previousPeaksWithHeights:B}=await Me(m,p.newData,p.leftInputs);await j(t,p.leafIndex,{newData:p.newData,event:p,blockNumber:p.blockNumber,rootCid:b,peaksWithHeights:B}),m=B,w=b}const X=new AbortController,O=R(Ut(e,t,w,{signal:X.signal}).catch(p=>{if((p==null?void 0:p.name)==="AbortError")return!1;throw p}));_.push({...O,controller:X,cid:w});const st=_.findIndex(p=>p.isFulfilled()&&p.getValue());if(st!==-1){_.forEach(B=>B.controller.abort());const p=_[st].cid,b=await K(t,u);if(b.length!==0)throw new Error("Unexpectedly missing newData for leaf indices: "+b.join(", "));console.log(`[Client] 📥 Downloaded all data for root CID ${(p==null?void 0:p.toString())??"undefined"} from IPFS.`),console.log("[Client] 🙌 Successfully resolved all remaining data from IPFS!"),console.log("[Client] 🌲 Your accumulator client has acquired all data!"),await t.persist();return}if(y<=g)break}_.forEach(C=>C.controller.abort()),await Promise.allSettled(_.map(C=>C.promise));const k=await K(t,u);if(k.length!==0)throw new Error("[Client] Missing newData for leaf indices: "+k.join(", "));console.log("[Client] 🦾 Fully synced backwards using only event data and local DB data (no data used from IPFS)"),console.log("[Client] 🌲 Your accumulator client has acquired all data!"),await t.persist()}async function We(e,t,n,o,r,s,i,a,l,c,u,d,f,g,E,w,y=1e4){if(a())return;l(!0);let m=!1;r?(console.log(`[Client] 🔗 Detected ETHEREUM_WS_RPC_URL: ${r}`),m=await Ge(r),m||console.log("[Client] ❌ WS endpoint does not support eth_subscribe, falling back to polling.")):console.log("[Client] 👎 No ETHEREUM_WS_RPC_URL provided, will use polling."),console.log(`[Client] 👀 Using ${m?"websocket subscription":"HTTP polling"} to monitor the chain for new data insertions.`),m?$t({mmr:e,storageAdapter:t,ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,ws:s,setWs:i,getLastProcessedBlock:d,setLastProcessedBlock:f,newLeafEventSubscribers:u,contractAddress:n,getAccumulatorDataCalldataOverride:g,eventTopicOverride:w}):Ht({mmr:e,storageAdapter:t,ethereumHttpRpcUrl:o,contractAddress:n,getLiveSyncRunning:a,setLiveSyncInterval:c,newLeafEventSubscribers:u,getLastProcessedBlock:d,setLastProcessedBlock:f,getAccumulatorDataCalldataOverride:g,getLatestCidCalldataOverride:E,eventTopicOverride:w,pollIntervalMs:y})}function Ot(e,t,n,o,r){o(!1),n()&&(clearTimeout(n()),r(void 0)),e&&(e.close(),t(void 0))}async function Ge(e){return!e.startsWith("ws://")&&!e.startsWith("wss://")?(console.log(`[Client] 👎 ETHEREUM_WS_RPC_URL is not a ws:// or wss:// URL: ${e}`),!1):(console.log(`[Client] 🙏 Attempting to open WebSocket and send eth_subscribe to ${e}...`),await new Promise(t=>{let n=null,o=!1;const r=setTimeout(()=>{o||(o=!0,n&&n.close(),t(!1))},3e3);try{n=new WebSocket(e),n.onopen=()=>{const s=JSON.stringify({jsonrpc:"2.0",id:1,method:"eth_subscribe",params:["newHeads"]});n.send(s)},n.onmessage=s=>{try{const i=JSON.parse(s.data);i.id===1&&(i.result||i.error)&&(o||(o=!0,clearTimeout(r),n.close(),t(!i.error)))}catch{}},n.onerror=()=>{o||(o=!0,clearTimeout(r),n.close(),t(!1))},n.onclose=()=>{o||(o=!0,clearTimeout(r),t(!1))}}catch{o||(o=!0,clearTimeout(r),n&&n.close(),t(!1))}}))}function Ht(e){const{mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:r,getLiveSyncRunning:s,setLiveSyncInterval:i,newLeafEventSubscribers:a,getLastProcessedBlock:l,setLastProcessedBlock:c,getAccumulatorDataCalldataOverride:u,getLatestCidCalldataOverride:d,eventTopicOverride:f,pollIntervalMs:g}=e,E=async()=>{try{const w=await N({ethereumHttpRpcUrl:o,contractAddress:r,getAccumulatorDataCalldataOverride:u}),{meta:y}=w,m=y.previousInsertBlockNumber;if(m>l()){const _=await rt({ethereumHttpRpcUrl:o,contractAddress:r,fromBlock:l()+1,toBlock:m,eventTopicOverride:f});for(const R of _)await Mt({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:r,event:R,newLeafEventSubscribers:a,getAccumulatorDataCalldataOverride:u,getLatestCidCalldataOverride:d,eventTopicOverride:f});c(m)}}catch(w){console.error("[LiveSync] Error during polling:",w)}s()&&i(setTimeout(E,g??1e4))};E()}function $t(e){const{mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,ws:s,setWs:i,getLastProcessedBlock:a,setLastProcessedBlock:l,newLeafEventSubscribers:c,contractAddress:u,getAccumulatorDataCalldataOverride:d,eventTopicOverride:f}=e;if(!r){console.error("[Client] No ETHEREUM_WS_RPC_URL set. Cannot start subscription sync.");return}if(s){console.warn("[Client] Subscription WebSocket already running.");return}console.log(`[Client] Connecting to WS: ${r}`);const g=new WebSocket(r);i(g),g.onopen=()=>{console.log("[Client] WebSocket open. Subscribing to newHeads...");const w=JSON.stringify({jsonrpc:"2.0",id:1,method:"eth_subscribe",params:["newHeads"]});g.send(w)};let E=null;g.onmessage=async w=>{try{const y=JSON.parse(w.data);if(y.id===1&&y.result){E=y.result,console.log(`[Client] Subscribed to newHeads. Subscription id: ${E}`);return}if(y.method==="eth_subscription"&&y.params&&y.params.subscription===E){const m=y.params.result.hash;console.log(`[Client] New block: ${m}. Fetching events...`);try{const{meta:_}=await N({ethereumHttpRpcUrl:o,contractAddress:u,getAccumulatorDataCalldataOverride:d}),R=a(),k=_.previousInsertBlockNumber;if(k>R){const C=await rt({ethereumHttpRpcUrl:o,contractAddress:u,fromBlock:R+1,toBlock:k,eventTopicOverride:f});for(const P of C)await Mt({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:u,event:P,newLeafEventSubscribers:c,getAccumulatorDataCalldataOverride:d,eventTopicOverride:f});l(k)}}catch(_){console.error("[LiveSync] Error during WS event processing:",_)}}}catch(y){console.error("[Client] Error parsing WS message:",y)}},g.onerror=w=>{console.error("[Client] WebSocket error:",w)},g.onclose=()=>{console.log("[Client] WebSocket closed."),e.setWs(void 0)}}async function Mt(e){const{mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:r,event:s,newLeafEventSubscribers:i,getAccumulatorDataCalldataOverride:a,getLatestCidCalldataOverride:l,eventTopicOverride:c}=e;await Wt(n,o,r,s,i,c),await Gt(t,n,s.leafIndex,s.newData);for(const d of i)d(s.leafIndex,G(s.newData));const{meta:u}=await N({ethereumHttpRpcUrl:o,contractAddress:r,getAccumulatorDataCalldataOverride:a});if(t.leafCount-1===u.leafCount-1)try{const d=await t.rootCIDAsBase32(),f=await Ue({ethereumHttpRpcUrl:o,contractAddress:r,getLatestCidCalldataOverride:l});d!==f.toString()?console.warn(`[Client] 🧠 Sanity check: ❌ Local (${d} )and on-chain (${f.toString()}) root CIDs do NOT match!`):console.log("[Client] 🧠 Sanity check: 😅 Local and on-chain root CIDs match!")}catch(d){console.warn("[Client] 🧠 Sanity check: ❌ Failed to compare root CIDs:",d)}console.log(`[Client] 🍃 Processed new leaf with index ${s.leafIndex}`)}async function Wt(e,t,n,o,r,s){const i=await e.getHighestContiguousLeafIndexWithData();if(!(o.leafIndex<=i)){if(o.leafIndex>i+1){console.log(`[Client] 📌 Missing event for leaf indexes ${i+1} to ${o.leafIndex-1}. Getting them now...`);const a=await $e(t,n,o.leafIndex-1,o.previousInsertBlockNumber,i+1,s);for(let l=0;l<a.length;l++)await Wt(e,t,n,a[l],r,s);console.log("[Client] 👍 Got the missing events.")}await j(e,o.leafIndex,re(o))}}async function Gt(e,t,n,o){const r=e.leafCount-1;if(!(n<=r)){if(n>r+1){console.log(`[Client] 📌 Lower indexed leaves ${r+1} to ${n-1} have yet to be processed by the MMR. Processing them now...`);const s=[];for(let i=r+1;i<n;i++){const a=await J(t,i);if(a===void 0)throw new Error(`Missing leaf data for leaf index ${i}`);s.push({leafIndex:i,newData:a.newData})}for(let i=0;i<s.length;i++)await Gt(e,t,s[i].leafIndex,s[i].newData);console.log("[Client] 👍 Processed the missing events in the MMR.")}await bt(t,e,n,o)}}function Ve(e,t){return e.push(t),()=>{const n=e.indexOf(t);n!==-1&&e.splice(n,1)}}async function je(e){const t={storageAdapter:e,getLeafRecord:async n=>{const o=await J(e,n);return o===void 0?null:o},putLeafRecord:async(n,o)=>{await j(t.storageAdapter,n,o)},getLeafIndexesWithMissingNewData:async()=>{const n=await t.storageAdapter.getHighestContiguousLeafIndexWithData();return K(t.storageAdapter,n)},getCIDDataPairFromDB:n=>Pt(t.storageAdapter,n),iterateTrailPairs:()=>ae(t.storageAdapter),get:n=>t.storageAdapter.get(n),put:(n,o)=>t.storageAdapter.put(n,o),delete:n=>t.storageAdapter.delete(n)};return t}function Vt(){return typeof window<"u"&&typeof window.document<"u"}function jt(){return typeof process<"u"&&!!(process.versions&&process.versions.node)}class Y{async getHighestContiguousLeafIndexWithData(){const t=[];for await(const{key:o,value:r}of this.iterate("leaf:")){const s=typeof o=="string"&&o.match(/^leaf:(\d+):newData$/);if(s){const i=parseInt(s[1],10);r!=null&&t.push(i)}}if(t.length===0)return-1;t.sort((o,r)=>o-r);let n=-1;for(let o=0;o<t.length&&t[o]===o;o++)n=o;return n}constructor(t="cid-accumulator",n="kv"){this._instanceId=Y._nextId++,this.dbName=t,this.storeName=n,this.dbPromise=this.openDB()}openDB(){if(typeof indexedDB>"u")throw new Error("IndexedDB is not available in this environment.");return new Promise((t,n)=>{const o=indexedDB.open(this.dbName,1);o.onupgradeneeded=()=>{o.result.createObjectStore(this.storeName)},o.onsuccess=()=>{t(o.result)},o.onerror=()=>{console.error(`[IndexedDBAdapter] onerror (instanceId=${this._instanceId})`,o.error),n(o.error)}})}async withStore(t,n){const o=await this.dbPromise;return new Promise((r,s)=>{const a=o.transaction(this.storeName,t).objectStore(this.storeName),l=n(a);l.onsuccess=()=>r(l.result),l.onerror=()=>s(l.error)})}async get(t){return await this.withStore("readonly",n=>n.get(t))}async put(t,n){await this.withStore("readwrite",o=>o.put(n,t))}async delete(t){await this.withStore("readwrite",n=>n.delete(t))}async*iterate(t){const n=await this.dbPromise;if(!n)throw new Error("IndexedDB database not initialized.");const s=n.transaction(this.storeName,"readonly").objectStore(this.storeName).openCursor(),i=await new Promise((a,l)=>{const c=[];s.onsuccess=()=>{const u=s.result;u?(typeof u.key=="string"&&u.key.startsWith(t)&&c.push({key:u.key,value:u.value}),u.continue()):a(c)},s.onerror=()=>l(s.error)});for(const a of i)yield a}async open(){await this.dbPromise}async persist(){}async close(){}async createIndexByPayloadSlice(t,n){const o=new Map;for await(const{value:r}of this.iterate("leaf:")){const s=r.slice(t,t+n);o.has(s)||o.set(s,[]),o.get(s).push(r)}return o}}Y._nextId=1;async function Je(e){let t;if(Vt())t=new Y;else{const n=await Z(()=>import("./JSMapAdapter-D29maUEw.js"),[]);t=new n.JSMapAdapter(e.DB_PATH??"./.db/accumulator.json")}return await je(t)}class Ye{constructor(t,n,o,r,s){this.gatewayUrl=t.replace(/\/?ipfs\/?$/,"").replace(/\/$/,""),this.apiUrl=n==null?void 0:n.replace(/\/$/,""),this.shouldPut=o&&n!==void 0,this.shouldPin=r&&n!==void 0,this.shouldProvide=s&&n!==void 0&&!Vt()}async getBlock(t){const n=`${this.gatewayUrl}/ipfs/${t.toString()}`,o=await fetch(n,{method:"GET"});if(!o.ok)throw new Error(`IPFS block/get failed: ${o.status} ${o.statusText}`);const r=new Uint8Array(await o.arrayBuffer());return await V(r,t,"[UniversalIpfsAdapter.getBlock] 🚨 IPFS Gateway returned invalid data!"),r}async putBlock(t,n){if(se(n,t)||console.warn(`[UniversalIpfsAdapter.putBlock] ‼️ CID/Data pair is invalid. dagCborEncodedData: ${n}, expectedCID: ${t.toString()}`),!this.shouldPut)return;const o=`${this.apiUrl}/api/v0/block/put?format=dag-cbor&mhtype=sha2-256&pin=${this.shouldPin}`,r=new FormData;r.append("data",new Blob([n]));const s=await fetch(o,{method:"POST",body:r});if(!s.ok)throw new Error(`IPFS block/put failed: ${s.status} ${s.statusText}`);const i=await s.json(),a=h.parse(i.Key);a.toString()!==t.toString()&&console.warn(`[UniversalIpfsAdapter.putBlock] ‼️ CID returned by the IPFS API was ${a.toString()} but you expected ${t.toString()}`)}async provide(t){if(!this.shouldProvide)return;const n=`${this.apiUrl}/api/v0/dht/provide?arg=${t.toString()}`;fetch(n).catch(()=>{})}}function Xe(e,t,n,o,r){return{ipfsAdapter:e,shouldPut:n,shouldPin:o,shouldProvide:r,getAndResolveCID:(s,i)=>Ut(e,t,s,i),rePinAllDataToIPFS:()=>He(e,t,n,o,r),putPinProvideToIPFS:({cid:s,dagCborEncodedData:i})=>Ft(e,n,r,s,i)}}async function qe(e,t){const n=new Ye(e.IPFS_GATEWAY_URL,e.IPFS_API_URL,e.IPFS_PUT_IF_POSSIBLE,e.IPFS_PIN_IF_POSSIBLE,e.IPFS_PROVIDE_IF_POSSIBLE);let o=e.IPFS_PUT_IF_POSSIBLE&&e.IPFS_API_URL!==void 0,r=e.IPFS_PIN_IF_POSSIBLE&&e.IPFS_API_URL!==void 0,s=e.IPFS_PROVIDE_IF_POSSIBLE&&e.IPFS_API_URL!==void 0&&jt();o||(r=!1),r||(s=!1),console.log("[Client] 👀 Checking IPFS Gateway connection...");try{await n.getBlock(x),console.log("[Client] 🔗 Connected to IPFS Gateway.")}catch(a){throw console.error("[Client] ❌ Failed to connect to IPFS Gateway:",a),new Error("Failed to connect to IPFS Gateway. Must abort. See above error.")}if(o){console.log("[Client] 👀 Checking IPFS API connection (attempting to PUT a block)...");try{await n.putBlock(x,v(null)),console.log("[Client] 🔗 Connected to IPFS API and verified it can PUT blocks.")}catch(a){o=!1,r=!1,console.error("[Client] ❌ Failed to connect to IPFS API:",a),console.log("[Client] 🤷‍♂️ Will continue without IPFS API connection (Using IPFS Gateway only).")}}if(s&&o){console.log("[Client] 👀 Checking if IPFS API can provide (advertise) blocks...");try{await n.provide(x),console.log("[Client] 🔗 Connected to IPFS API and verified it can PROVIDE blocks.")}catch(a){s=!1,console.error("[Client] ❌ Failed to verify that the IPFS API can provide (advertise) blocks.",a),console.log("[Client] 🤷‍♂️ Will continue without telling IPFS API to provide (advertise) blocks.")}}const i=Xe(n,t,o,r,s);return console.log("[Client] 📜 IPFS Capability Summary:"),console.log("[Client] 📜 Summary: IPFS Gateway connected: YES"),console.log(`[Client] 📜 Summary: IPFS API PUT is set up: ${o?"YES":"NO"}`),console.log(`[Client] 📜 Summary: IPFS API PIN is set up: ${r?"YES":"NO"}`),console.log(`[Client] 📜 Summary: IPFS API PROVIDE is set up: ${s?"YES":"NO"}`),i}function Ke(e,t,n,o,r,s,i,a,l,c,u){let d={ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,contractAddress:s,highestCommittedLeafIndex:-1,lastProcessedBlock:i,liveSyncRunning:!1,liveSyncInterval:void 0,websocket:void 0,newLeafEventSubscribers:[],onNewLeaf:f=>Ve(d.newLeafEventSubscribers,f),startSubscriptionSync:()=>$t({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,ethereumWsRpcUrl:r,ws:d.websocket,setWs:f=>{d.websocket=f},getLastProcessedBlock:()=>d.lastProcessedBlock,setLastProcessedBlock:f=>{d.lastProcessedBlock=f},newLeafEventSubscribers:d.newLeafEventSubscribers,contractAddress:s,getAccumulatorDataCalldataOverride:a,eventTopicOverride:c}),startPollingSync:()=>Ht({mmr:t,storageAdapter:n,ethereumHttpRpcUrl:o,contractAddress:s,getLiveSyncRunning:()=>d.liveSyncRunning,setLiveSyncInterval:f=>{d.liveSyncInterval=f},newLeafEventSubscribers:d.newLeafEventSubscribers,getLastProcessedBlock:()=>d.lastProcessedBlock,setLastProcessedBlock:f=>{d.lastProcessedBlock=f},getAccumulatorDataCalldataOverride:a,eventTopicOverride:c}),startLiveSync:()=>We(t,n,s,o,r,d.websocket,f=>{d.websocket=f},()=>d.liveSyncRunning,f=>{d.liveSyncRunning=f},f=>{d.liveSyncInterval=f},d.newLeafEventSubscribers,()=>d.lastProcessedBlock,f=>{d.lastProcessedBlock=f},a,l,c),stopLiveSync:()=>Ot(d.websocket,f=>{d.websocket=f},()=>d.liveSyncInterval,f=>{d.liveSyncRunning=f},f=>{d.liveSyncInterval=f}),syncBackwardsFromLatest:()=>Nt(e,n,o,s,f=>{d.lastProcessedBlock=f},a,c,u)};return d}async function ze(e,t,n,o,r,s,i){console.log("[Client] 👀 Checking Ethereum connection...");let a=0;try{const{meta:c}=await N({ethereumHttpRpcUrl:t.ETHEREUM_HTTP_RPC_URL,contractAddress:e,getAccumulatorDataCalldataOverride:t.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE});console.log(`[Client] 🔗 Connected to Ethereum. Target contract address: ${e}`),a=c.deployBlockNumber-1}catch(c){throw console.error("[Client] ❌ Failed to connect to Ethereum node:",c),new Error("Failed to connect to Ethereum node. See above error.")}return Ke(o.ipfsAdapter,r,n,t.ETHEREUM_HTTP_RPC_URL,t.ETHEREUM_WS_RPC_URL,e,a,s,t.GET_LATEST_CID_CALLDATA_OVERRIDE,i,t.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL??1e3)}async function Qe(e){const t=[];for await(const{key:o,value:r}of e.iterate("leaf:")){const s=o.match(/^leaf:(\d+):newData$/);s&&t.push({index:Number(s[1]),data:r})}const n=JSON.stringify(t,null,2);if(jt()){const o=await Z(()=>import("./__vite-browser-external-BIHI7g3E.js"),[]),r=`accumulator-data-${Date.now()}.json`;return await o.writeFile(r,n,"utf8"),console.log(`[Client] Accumulator data written to ${r}`),r}else{const o=new Blob([n],{type:"application/json"}),r=URL.createObjectURL(o),s=document.createElement("a");return s.href=r,s.download=`accumulator-data-${Date.now()}.json`,document.body.appendChild(s),s.click(),document.body.removeChild(s),URL.revokeObjectURL(r),s.download}}function Ze(e,t,n){return{getHighestIndex:async()=>t(),getData:async o=>{const r=await e.get(`leaf:${o}:newData`);if(r)return r},getRange:async(o,r)=>{if(o<0&&(o=0),r<0&&(r=0),o>t()&&(o=t()),r>t()&&(r=t()),o>r)return[];const s=[];for(let i=o;i<=r;i++){const a=await e.get(`leaf:${i}:newData`);a&&s.push({index:i,data:a})}return s},subscribe:o=>n(o),downloadAll:async()=>Qe(e),iterate:e.iterate.bind(e,"leaf:"),createIndexByPayloadSlice:e.createIndexByPayloadSlice.bind(e)}}function tn(e,t){console.log(`[Client] ⚙ Config: CONTRACT_ADDRESS: ${e}`),console.log(`[Client] ⚙ Config: ETHEREUM_HTTP_RPC_URL: ${t.ETHEREUM_HTTP_RPC_URL}`),console.log(`[Client] ⚙ Config: ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL: ${t.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL??"undefined"}`),console.log(`[Client] ⚙ Config: ETHEREUM_WS_RPC_URL: ${t.ETHEREUM_WS_RPC_URL??"undefined"}`),console.log(`[Client] ⚙ Config: IPFS_GATEWAY_URL: ${t.IPFS_GATEWAY_URL}`),console.log(`[Client] ⚙ Config: IPFS_API_URL: ${t.IPFS_API_URL??"undefined"}`),console.log(`[Client] ⚙ Config: IPFS_PUT_IF_POSSIBLE: ${t.IPFS_PUT_IF_POSSIBLE}`),console.log(`[Client] ⚙ Config: IPFS_PIN_IF_POSSIBLE: ${t.IPFS_PIN_IF_POSSIBLE}`),console.log(`[Client] ⚙ Config: IPFS_PROVIDE_IF_POSSIBLE: ${t.IPFS_PROVIDE_IF_POSSIBLE}`),console.log(`[Client] ⚙ Config: DB_PATH: ${t.DB_PATH??"undefined"}`),console.log(`[Client] ⚙ Config: GET_LATEST_CID_CALLDATA_OVERRIDE: ${t.GET_LATEST_CID_CALLDATA_OVERRIDE??"undefined"}`),console.log(`[Client] ⚙ Config: GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE: ${t.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE??"undefined"}`),console.log(`[Client] ⚙ Config: LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE: ${t.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE??"undefined"}`)}class en{constructor(t,n){this.contractAddress=t,this.config=n??I,this.mmr=new le,tn(this.contractAddress,this.config)}async init(){this.storage=await Je(this.config),await this.storage.storageAdapter.open();const t=await this.storage.storageAdapter.getHighestContiguousLeafIndexWithData();console.log(`[Client] 📤 Found ${t+1} leafs in DB`),this.ipfs=await qe(this.config,this.storage.storageAdapter),this.ipfs.shouldPin&&this.mmr.subscribeToLeafInsertTrail(n=>{var o;for(const{cid:r,dagCborEncodedData:s}of n)(o=this.ipfs)==null||o.putPinProvideToIPFS({cid:r,dagCborEncodedData:s})}),this.sync=await ze(this.contractAddress,this.config,this.storage.storageAdapter,this.ipfs,this.mmr,this.config.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE,this.config.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE),this.data=Ze(this.storage.storageAdapter,()=>this.mmr.leafCount-1,this.sync.onNewLeaf.bind(this.sync))}async start(){if(console.log("[Client] 🚀 Starting AccumulatorClient..."),await this.init(),!this.ipfs||!this.sync||!this.storage)throw new Error("Not all namespaces present. This should never happen.");await Nt(this.ipfs.ipfsAdapter,this.storage.storageAdapter,this.sync.ethereumHttpRpcUrl,this.sync.contractAddress,t=>this.sync.lastProcessedBlock=t,this.config.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE,this.config.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE,this.config.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL??1e3),ce(this.mmr,this.storage.storageAdapter),this.sync.startLiveSync(),console.log("[Client] 🟢 Client is ready to use.")}async shutdown(){if(!this.sync||!this.ipfs||!this.storage)throw new Error("Not all namespaces present. This should never happen.");console.log("[Client] 👋 Shutting down gracefully."),Ot(this.sync.websocket,t=>this.sync.websocket=t,()=>this.sync.liveSyncInterval,t=>this.sync.liveSyncRunning=t,t=>this.sync.liveSyncInterval=t),await this.storage.storageAdapter.close(),console.log("[Client] 🏁 Done.")}}const nn=document.getElementById("client-form"),Jt=document.getElementById("output"),on=document.getElementById("clear-db-btn");window.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("eth-http-url"),t=document.getElementById("eth-max-block-range"),n=document.getElementById("eth-ws-url"),o=document.getElementById("ipfs-gateway-url"),r=document.getElementById("ipfs-api-url"),s=document.getElementById("db-path");e&&I.ETHEREUM_HTTP_RPC_URL&&(e.placeholder=I.ETHEREUM_HTTP_RPC_URL),t&&I.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL&&(t.placeholder=I.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL),n&&I.ETHEREUM_WS_RPC_URL&&(n.placeholder=I.ETHEREUM_WS_RPC_URL),o&&I.IPFS_GATEWAY_URL&&(o.placeholder=I.IPFS_GATEWAY_URL),r&&I.IPFS_API_URL&&(r.placeholder=I.IPFS_API_URL),s&&I.DB_PATH&&(s.placeholder=I.DB_PATH)});function S(e){Jt.textContent+=e+`
`}nn.addEventListener("submit",async e=>{e.preventDefault(),Jt.textContent="";const t=document.getElementById("contract-address").value,n={...I,ETHEREUM_HTTP_RPC_URL:document.getElementById("eth-http-url").value||I.ETHEREUM_HTTP_RPC_URL,ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL:document.getElementById("eth-max-block-range").value!==""?Number(document.getElementById("eth-max-block-range").value):I.ETHEREUM_MAX_BLOCK_RANGE_PER_HTTP_RPC_CALL,ETHEREUM_WS_RPC_URL:document.getElementById("eth-ws-url").value||I.ETHEREUM_WS_RPC_URL,IPFS_GATEWAY_URL:document.getElementById("ipfs-gateway-url").value||I.IPFS_GATEWAY_URL,IPFS_API_URL:document.getElementById("ipfs-api-url").value||I.IPFS_API_URL,IPFS_PUT_IF_POSSIBLE:document.getElementById("ipfs-put-if-possible").checked,IPFS_PIN_IF_POSSIBLE:document.getElementById("ipfs-pin-if-possible").checked,IPFS_PROVIDE_IF_POSSIBLE:document.getElementById("ipfs-provide-if-possible").checked,DB_PATH:document.getElementById("db-path").value||I.DB_PATH},o=document.getElementById("get-latest-cid-override").value,r=document.getElementById("get-accumulator-data-override").value,s=document.getElementById("leaf-insert-event-override").value;o&&(n.GET_LATEST_CID_CALLDATA_OVERRIDE=o),r&&(n.GET_ACCUMULATOR_DATA_CALLDATA_OVERRIDE=r),s&&(n.LEAF_INSERT_EVENT_SIGNATURE_OVERRIDE=s),S("Starting client...");try{const i=new en(t,n);window.accumulatorClient=i,await i.start(),S("Client started and synced!")}catch(i){S("Error: "+i.message)}});on.addEventListener("click",async()=>{S("Clearing local DB...");try{window.accumulatorClient&&typeof window.accumulatorClient.shutdown=="function"&&(await window.accumulatorClient.shutdown(),S("Client shut down."));const t=window.indexedDB.deleteDatabase("accumulator-client-db");t.onsuccess=()=>S("Local DB cleared (IndexedDB deleted)."),t.onerror=n=>S("Error clearing DB: "+n.target.error),t.onblocked=()=>S("DB deletion blocked. Please close other tabs using this site.")}catch(e){S("Error clearing DB: "+e.message)}});export{Z as _};
